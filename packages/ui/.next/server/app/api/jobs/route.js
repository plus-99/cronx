"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/jobs/route";
exports.ids = ["app/api/jobs/route"];
exports.modules = {

/***/ "better-sqlite3":
/*!*********************************!*\
  !*** external "better-sqlite3" ***!
  \*********************************/
/***/ ((module) => {

module.exports = require("better-sqlite3");

/***/ }),

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "pg":
/*!*********************!*\
  !*** external "pg" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("pg");

/***/ }),

/***/ "cluster":
/*!**************************!*\
  !*** external "cluster" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("cluster");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("net");

/***/ }),

/***/ "perf_hooks":
/*!*****************************!*\
  !*** external "perf_hooks" ***!
  \*****************************/
/***/ ((module) => {

module.exports = require("perf_hooks");

/***/ }),

/***/ "process":
/*!**************************!*\
  !*** external "process" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("process");

/***/ }),

/***/ "string_decoder":
/*!*********************************!*\
  !*** external "string_decoder" ***!
  \*********************************/
/***/ ((module) => {

module.exports = require("string_decoder");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("tls");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("util");

/***/ }),

/***/ "v8":
/*!*********************!*\
  !*** external "v8" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("v8");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("zlib");

/***/ }),

/***/ "(rsc)/../../node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fjobs%2Froute&page=%2Fapi%2Fjobs%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fjobs%2Froute.ts&appDir=%2Fhome%2Frunner%2Fworkspace%2Fpackages%2Fui%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2Fhome%2Frunner%2Fworkspace%2Fpackages%2Fui&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fjobs%2Froute&page=%2Fapi%2Fjobs%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fjobs%2Froute.ts&appDir=%2Fhome%2Frunner%2Fworkspace%2Fpackages%2Fui%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2Fhome%2Frunner%2Fworkspace%2Fpackages%2Fui&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/../../node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/../../node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/../../node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _home_runner_workspace_packages_ui_src_app_api_jobs_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/app/api/jobs/route.ts */ \"(rsc)/./src/app/api/jobs/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/jobs/route\",\n        pathname: \"/api/jobs\",\n        filename: \"route\",\n        bundlePath: \"app/api/jobs/route\"\n    },\n    resolvedPagePath: \"/home/runner/workspace/packages/ui/src/app/api/jobs/route.ts\",\n    nextConfigOutput,\n    userland: _home_runner_workspace_packages_ui_src_app_api_jobs_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/jobs/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1hcHAtbG9hZGVyLmpzP25hbWU9YXBwJTJGYXBpJTJGam9icyUyRnJvdXRlJnBhZ2U9JTJGYXBpJTJGam9icyUyRnJvdXRlJmFwcFBhdGhzPSZwYWdlUGF0aD1wcml2YXRlLW5leHQtYXBwLWRpciUyRmFwaSUyRmpvYnMlMkZyb3V0ZS50cyZhcHBEaXI9JTJGaG9tZSUyRnJ1bm5lciUyRndvcmtzcGFjZSUyRnBhY2thZ2VzJTJGdWklMkZzcmMlMkZhcHAmcGFnZUV4dGVuc2lvbnM9dHN4JnBhZ2VFeHRlbnNpb25zPXRzJnBhZ2VFeHRlbnNpb25zPWpzeCZwYWdlRXh0ZW5zaW9ucz1qcyZyb290RGlyPSUyRmhvbWUlMkZydW5uZXIlMkZ3b3Jrc3BhY2UlMkZwYWNrYWdlcyUyRnVpJmlzRGV2PXRydWUmdHNjb25maWdQYXRoPXRzY29uZmlnLmpzb24mYmFzZVBhdGg9JmFzc2V0UHJlZml4PSZuZXh0Q29uZmlnT3V0cHV0PSZwcmVmZXJyZWRSZWdpb249Jm1pZGRsZXdhcmVDb25maWc9ZTMwJTNEISIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBc0c7QUFDdkM7QUFDYztBQUNZO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnSEFBbUI7QUFDM0M7QUFDQSxjQUFjLHlFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZO0FBQ1osQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWlFO0FBQ3pFO0FBQ0E7QUFDQSxXQUFXLDRFQUFXO0FBQ3RCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDdUg7O0FBRXZIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHBsdXM5OS9jcm9ueC11aS8/YTk0NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcHBSb3V0ZVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLW1vZHVsZXMvYXBwLXJvdXRlL21vZHVsZS5jb21waWxlZFwiO1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLWtpbmRcIjtcbmltcG9ydCB7IHBhdGNoRmV0Y2ggYXMgX3BhdGNoRmV0Y2ggfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvcGF0Y2gtZmV0Y2hcIjtcbmltcG9ydCAqIGFzIHVzZXJsYW5kIGZyb20gXCIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL3BhY2thZ2VzL3VpL3NyYy9hcHAvYXBpL2pvYnMvcm91dGUudHNcIjtcbi8vIFdlIGluamVjdCB0aGUgbmV4dENvbmZpZ091dHB1dCBoZXJlIHNvIHRoYXQgd2UgY2FuIHVzZSB0aGVtIGluIHRoZSByb3V0ZVxuLy8gbW9kdWxlLlxuY29uc3QgbmV4dENvbmZpZ091dHB1dCA9IFwiXCJcbmNvbnN0IHJvdXRlTW9kdWxlID0gbmV3IEFwcFJvdXRlUm91dGVNb2R1bGUoe1xuICAgIGRlZmluaXRpb246IHtcbiAgICAgICAga2luZDogUm91dGVLaW5kLkFQUF9ST1VURSxcbiAgICAgICAgcGFnZTogXCIvYXBpL2pvYnMvcm91dGVcIixcbiAgICAgICAgcGF0aG5hbWU6IFwiL2FwaS9qb2JzXCIsXG4gICAgICAgIGZpbGVuYW1lOiBcInJvdXRlXCIsXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiYXBwL2FwaS9qb2JzL3JvdXRlXCJcbiAgICB9LFxuICAgIHJlc29sdmVkUGFnZVBhdGg6IFwiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9wYWNrYWdlcy91aS9zcmMvYXBwL2FwaS9qb2JzL3JvdXRlLnRzXCIsXG4gICAgbmV4dENvbmZpZ091dHB1dCxcbiAgICB1c2VybGFuZFxufSk7XG4vLyBQdWxsIG91dCB0aGUgZXhwb3J0cyB0aGF0IHdlIG5lZWQgdG8gZXhwb3NlIGZyb20gdGhlIG1vZHVsZS4gVGhpcyBzaG91bGRcbi8vIGJlIGVsaW1pbmF0ZWQgd2hlbiB3ZSd2ZSBtb3ZlZCB0aGUgb3RoZXIgcm91dGVzIHRvIHRoZSBuZXcgZm9ybWF0LiBUaGVzZVxuLy8gYXJlIHVzZWQgdG8gaG9vayBpbnRvIHRoZSByb3V0ZS5cbmNvbnN0IHsgcmVxdWVzdEFzeW5jU3RvcmFnZSwgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MgfSA9IHJvdXRlTW9kdWxlO1xuY29uc3Qgb3JpZ2luYWxQYXRobmFtZSA9IFwiL2FwaS9qb2JzL3JvdXRlXCI7XG5mdW5jdGlvbiBwYXRjaEZldGNoKCkge1xuICAgIHJldHVybiBfcGF0Y2hGZXRjaCh7XG4gICAgICAgIHNlcnZlckhvb2tzLFxuICAgICAgICBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlXG4gICAgfSk7XG59XG5leHBvcnQgeyByb3V0ZU1vZHVsZSwgcmVxdWVzdEFzeW5jU3RvcmFnZSwgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MsIG9yaWdpbmFsUGF0aG5hbWUsIHBhdGNoRmV0Y2gsICB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHAtcm91dGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fjobs%2Froute&page=%2Fapi%2Fjobs%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fjobs%2Froute.ts&appDir=%2Fhome%2Frunner%2Fworkspace%2Fpackages%2Fui%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2Fhome%2Frunner%2Fworkspace%2Fpackages%2Fui&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/../core/dist/executor.js":
/*!********************************!*\
  !*** ../core/dist/executor.js ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.JobExecutor = exports.ExponentialBackoffStrategy = exports.FixedBackoffStrategy = void 0;\nconst crypto_1 = __webpack_require__(/*! crypto */ \"crypto\");\nconst types_js_1 = __webpack_require__(/*! ./types.js */ \"(rsc)/../core/dist/types.js\");\nclass FixedBackoffStrategy {\n    constructor(delay = 1000){\n        this.delay = delay;\n    }\n    calculate(attempt) {\n        return this.delay;\n    }\n}\nexports.FixedBackoffStrategy = FixedBackoffStrategy;\nclass ExponentialBackoffStrategy {\n    constructor(baseDelay = 1000, maxDelay = 30000, factor = 2){\n        this.baseDelay = baseDelay;\n        this.maxDelay = maxDelay;\n        this.factor = factor;\n    }\n    calculate(attempt) {\n        const delay = this.baseDelay * Math.pow(this.factor, attempt - 1);\n        return Math.min(delay, this.maxDelay);\n    }\n}\nexports.ExponentialBackoffStrategy = ExponentialBackoffStrategy;\nclass JobExecutor {\n    constructor(storage, workerId, logger, metrics // MetricsCollector (avoiding circular import)\n    ){\n        this.storage = storage;\n        this.workerId = workerId;\n        this.logger = logger;\n        this.metrics = metrics;\n        this.runningJobs = new Set();\n        this.lockTTL = 60000; // 1 minute lock TTL\n        this.lockExtendInterval = 30000; // Extend lock every 30 seconds\n    }\n    async executeJob(job) {\n        const runId = (0, crypto_1.randomUUID)();\n        // Check if job is paused before attempting execution\n        if (job.isPaused) {\n            this.logger?.info(`Job '${job.name}' is paused, skipping execution`, {\n                job: job.name,\n                workerId: this.workerId\n            });\n            return {\n                id: runId,\n                jobName: job.name,\n                status: \"completed\",\n                startTime: new Date(),\n                endTime: new Date(),\n                attempt: 1,\n                result: {\n                    skipped: true,\n                    reason: \"Job is paused\"\n                }\n            };\n        }\n        const isLockAcquired = await this.acquireJobLock(job.name);\n        if (!isLockAcquired) {\n            this.logger?.info(`Job '${job.name}' is already running on another worker`, {\n                job: job.name,\n                workerId: this.workerId\n            });\n            // Return a run indicating it was skipped\n            return {\n                id: runId,\n                jobName: job.name,\n                status: \"completed\",\n                startTime: new Date(),\n                endTime: new Date(),\n                attempt: 1,\n                result: {\n                    skipped: true,\n                    reason: \"Already running on another worker\"\n                }\n            };\n        }\n        const jobRun = {\n            id: runId,\n            jobName: job.name,\n            status: \"pending\",\n            attempt: 1\n        };\n        try {\n            await this.storage.saveJobRun(jobRun);\n            return await this.executeJobWithRetries(job, jobRun);\n        } finally{\n            await this.releaseJobLock(job.name);\n        }\n    }\n    async executeJobWithRetries(job, initialRun) {\n        const maxRetries = job.options.retries || 0;\n        let currentRun = initialRun;\n        for(let attempt = 1; attempt <= maxRetries + 1; attempt++){\n            currentRun.attempt = attempt;\n            currentRun.status = \"running\";\n            currentRun.startTime = new Date();\n            await this.storage.saveJobRun(currentRun);\n            // Set up lock extension for long-running jobs\n            const lockExtender = this.setupLockExtension(job.name);\n            try {\n                this.logger?.info(`Executing job '${job.name}' (attempt ${attempt}/${maxRetries + 1})`, {\n                    job: job.name,\n                    attempt,\n                    runId: currentRun.id\n                });\n                // Record job started metric\n                this.metrics?.recordJobStarted(job.name, this.workerId);\n                const result = await this.executeJobHandler(job);\n                // Job completed successfully\n                currentRun.status = \"completed\";\n                currentRun.endTime = new Date();\n                currentRun.result = result;\n                await this.storage.saveJobRun(currentRun);\n                const duration = currentRun.endTime.getTime() - currentRun.startTime.getTime();\n                this.logger?.info(`Job '${job.name}' completed successfully`, {\n                    job: job.name,\n                    attempt,\n                    runId: currentRun.id,\n                    duration\n                });\n                // Record job completion metric\n                this.metrics?.recordJobCompleted(job.name, this.workerId, duration);\n                // Call success callback if provided\n                if (job.options.onSuccess) {\n                    try {\n                        await job.options.onSuccess(result);\n                    } catch (callbackError) {\n                        this.logger?.warn(`Success callback failed for job '${job.name}': ${callbackError}`, {\n                            job: job.name,\n                            runId: currentRun.id\n                        });\n                    }\n                }\n                return currentRun;\n            } catch (error) {\n                currentRun.status = \"failed\";\n                currentRun.endTime = new Date();\n                currentRun.error = error instanceof Error ? error.message : String(error);\n                await this.storage.saveJobRun(currentRun);\n                const duration = currentRun.endTime.getTime() - currentRun.startTime.getTime();\n                const errorType = error instanceof Error ? error.constructor.name : \"Unknown\";\n                this.logger?.error(`Job '${job.name}' failed (attempt ${attempt}/${maxRetries + 1}): ${error}`, {\n                    job: job.name,\n                    attempt,\n                    runId: currentRun.id,\n                    error: error instanceof Error ? error.message : String(error)\n                });\n                // Record job failure metric (only for the final failure)\n                if (attempt === maxRetries + 1) {\n                    this.metrics?.recordJobFailed(job.name, this.workerId, duration, errorType);\n                }\n                // Call error callback if provided\n                if (job.options.onError) {\n                    try {\n                        await job.options.onError(error);\n                    } catch (callbackError) {\n                        this.logger?.warn(`Error callback failed for job '${job.name}': ${callbackError}`, {\n                            job: job.name,\n                            runId: currentRun.id\n                        });\n                    }\n                }\n                // If this was the last attempt, throw the error\n                if (attempt === maxRetries + 1) {\n                    throw new types_js_1.JobExecutionError(job.name, attempt, error);\n                }\n                // Wait before retry\n                const backoffStrategy = this.getBackoffStrategy(job.options.backoff);\n                const delay = backoffStrategy.calculate(attempt);\n                this.logger?.info(`Retrying job '${job.name}' in ${delay}ms`, {\n                    job: job.name,\n                    attempt,\n                    nextAttempt: attempt + 1,\n                    delay\n                });\n                await this.sleep(delay);\n                // Create new run for retry\n                currentRun = {\n                    id: (0, crypto_1.randomUUID)(),\n                    jobName: job.name,\n                    status: \"pending\",\n                    attempt: attempt + 1\n                };\n            } finally{\n                clearInterval(lockExtender);\n            }\n        }\n        return currentRun;\n    }\n    async executeJobHandler(job) {\n        const timeout = job.options.timeout;\n        if (!timeout) {\n            return await job.handler();\n        }\n        // Execute with timeout\n        return new Promise((resolve, reject)=>{\n            const timer = setTimeout(()=>{\n                reject(new Error(`Job '${job.name}' timed out after ${timeout}ms`));\n            }, timeout);\n            job.handler().then((result)=>{\n                clearTimeout(timer);\n                resolve(result);\n            }).catch((error)=>{\n                clearTimeout(timer);\n                reject(error);\n            });\n        });\n    }\n    getBackoffStrategy(strategy) {\n        switch(strategy){\n            case \"exponential\":\n                return new ExponentialBackoffStrategy();\n            case \"fixed\":\n            default:\n                return new FixedBackoffStrategy();\n        }\n    }\n    async acquireJobLock(jobName) {\n        const maxRetries = 3;\n        const baseDelay = 100; // 100ms base delay\n        for(let attempt = 1; attempt <= maxRetries; attempt++){\n            try {\n                const acquired = await this.storage.acquireLock(jobName, this.workerId, this.lockTTL);\n                if (acquired) {\n                    return true;\n                }\n                // If not acquired on first attempt, it might be genuine contention\n                if (attempt === 1) {\n                    this.logger?.debug(`Lock contention for job '${jobName}', will retry`, {\n                        job: jobName,\n                        workerId: this.workerId,\n                        attempt\n                    });\n                }\n                // Exponential backoff for retries\n                if (attempt < maxRetries) {\n                    const delay = baseDelay * Math.pow(2, attempt - 1);\n                    await this.sleep(delay);\n                }\n            } catch (error) {\n                this.logger?.error(`Failed to acquire lock for job '${jobName}' (attempt ${attempt}): ${error}`, {\n                    job: jobName,\n                    workerId: this.workerId,\n                    attempt\n                });\n                // For connection errors, retry with backoff\n                if (attempt < maxRetries) {\n                    const delay = baseDelay * Math.pow(2, attempt - 1);\n                    await this.sleep(delay);\n                }\n            }\n        }\n        return false;\n    }\n    async releaseJobLock(jobName) {\n        try {\n            await this.storage.releaseLock(jobName, this.workerId);\n        } catch (error) {\n            this.logger?.error(`Failed to release lock for job '${jobName}': ${error}`, {\n                job: jobName,\n                workerId: this.workerId\n            });\n        }\n    }\n    setupLockExtension(jobName) {\n        return setInterval(async ()=>{\n            try {\n                const extended = await this.storage.extendLock(jobName, this.workerId, this.lockTTL);\n                if (!extended) {\n                    this.logger?.warn(`Failed to extend lock for job '${jobName}' - may have been taken by another worker`, {\n                        job: jobName,\n                        workerId: this.workerId\n                    });\n                }\n            } catch (error) {\n                this.logger?.error(`Error extending lock for job '${jobName}': ${error}`, {\n                    job: jobName,\n                    workerId: this.workerId\n                });\n            }\n        }, this.lockExtendInterval);\n    }\n    sleep(ms) {\n        return new Promise((resolve)=>setTimeout(resolve, ms));\n    }\n}\nexports.JobExecutor = JobExecutor; //# sourceMappingURL=executor.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFtQzdCLFFBQU8sS0FBTTZCLE1BQUssQ0FBRSxFQUFFO2dCQUMxRXBDLEtBQUtPO2dCQUNMZixVQUFVLElBQUksQ0FBQ0EsUUFBUTs7UUFFM0I7SUFDRjtJQUVRbUMsbUJBQW1CcEIsT0FBZTtRQUN4QyxPQUFPMEQsWUFBWTtZQUNqQixJQUFJO2dCQUNGLE1BQU1DLFdBQVcsTUFBTSxJQUFJLENBQUMzRSxPQUFPLENBQUM0RSxVQUFVLENBQUM1RCxTQUFTLElBQUksQ0FBQ2YsUUFBUSxFQUFFLElBQUksQ0FBQ0ssT0FBTztnQkFDbkYsSUFBSSxDQUFDcUUsVUFBVTtvQkFDYixJQUFJLENBQUN6RSxNQUFNLEVBQUUwQyxLQUFLLGtDQUFrQzVCLFFBQU8sMENBQTJDLEVBQUU7d0JBQ3RHUCxLQUFLTzt3QkFDTGYsVUFBVSxJQUFJLENBQUNBLFFBQVE7O2dCQUUzQjtZQUNGLEVBQUUsT0FBTzRDLE9BQU87Z0JBQ2QsSUFBSSxDQUFDM0MsTUFBTSxFQUFFMkMsTUFBTSxpQ0FBaUM3QixRQUFPLEtBQU02QixNQUFLLENBQUUsRUFBRTtvQkFDeEVwQyxLQUFLTztvQkFDTGYsVUFBVSxJQUFJLENBQUNBLFFBQVE7O1lBRTNCO1FBQ0YsR0FBRyxJQUFJLENBQUNNLGtCQUFrQjtJQUM1QjtJQUVRa0QsTUFBTW9CLEVBQVU7UUFDdEIsT0FBTyxJQUFJaEIsUUFBUUMsQ0FBQUEsVUFBV0csV0FBV0gsU0FBU2U7SUFDcEQ7O0FBblRGdEYsbUJBQUEsR0FBQVEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AcGx1czk5L2Nyb254LXVpLy4uL3NyYy9leGVjdXRvci50cz9iZGNlIl0sIm5hbWVzIjpbImNyeXB0b18xIiwicmVxdWlyZSIsInR5cGVzX2pzXzEiLCJGaXhlZEJhY2tvZmZTdHJhdGVneSIsImNvbnN0cnVjdG9yIiwiZGVsYXkiLCJjYWxjdWxhdGUiLCJhdHRlbXB0IiwiZXhwb3J0cyIsIkV4cG9uZW50aWFsQmFja29mZlN0cmF0ZWd5IiwiYmFzZURlbGF5IiwibWF4RGVsYXkiLCJmYWN0b3IiLCJNYXRoIiwicG93IiwibWluIiwiSm9iRXhlY3V0b3IiLCJzdG9yYWdlIiwid29ya2VySWQiLCJsb2dnZXIiLCJtZXRyaWNzIiwicnVubmluZ0pvYnMiLCJTZXQiLCJsb2NrVFRMIiwibG9ja0V4dGVuZEludGVydmFsIiwiZXhlY3V0ZUpvYiIsImpvYiIsInJ1bklkIiwicmFuZG9tVVVJRCIsImlzUGF1c2VkIiwiaW5mbyIsIm5hbWUiLCJpZCIsImpvYk5hbWUiLCJzdGF0dXMiLCJzdGFydFRpbWUiLCJEYXRlIiwiZW5kVGltZSIsInJlc3VsdCIsInNraXBwZWQiLCJyZWFzb24iLCJpc0xvY2tBY3F1aXJlZCIsImFjcXVpcmVKb2JMb2NrIiwiam9iUnVuIiwic2F2ZUpvYlJ1biIsImV4ZWN1dGVKb2JXaXRoUmV0cmllcyIsInJlbGVhc2VKb2JMb2NrIiwiaW5pdGlhbFJ1biIsIm1heFJldHJpZXMiLCJvcHRpb25zIiwicmV0cmllcyIsImN1cnJlbnRSdW4iLCJsb2NrRXh0ZW5kZXIiLCJzZXR1cExvY2tFeHRlbnNpb24iLCJyZWNvcmRKb2JTdGFydGVkIiwiZXhlY3V0ZUpvYkhhbmRsZXIiLCJkdXJhdGlvbiIsImdldFRpbWUiLCJyZWNvcmRKb2JDb21wbGV0ZWQiLCJvblN1Y2Nlc3MiLCJjYWxsYmFja0Vycm9yIiwid2FybiIsImVycm9yIiwiRXJyb3IiLCJtZXNzYWdlIiwiU3RyaW5nIiwiZXJyb3JUeXBlIiwicmVjb3JkSm9iRmFpbGVkIiwib25FcnJvciIsIkpvYkV4ZWN1dGlvbkVycm9yIiwiYmFja29mZlN0cmF0ZWd5IiwiZ2V0QmFja29mZlN0cmF0ZWd5IiwiYmFja29mZiIsIm5leHRBdHRlbXB0Iiwic2xlZXAiLCJjbGVhckludGVydmFsIiwidGltZW91dCIsImhhbmRsZXIiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInRpbWVyIiwic2V0VGltZW91dCIsInRoZW4iLCJjbGVhclRpbWVvdXQiLCJjYXRjaCIsInN0cmF0ZWd5IiwiYWNxdWlyZWQiLCJhY3F1aXJlTG9jayIsImRlYnVnIiwicmVsZWFzZUxvY2siLCJzZXRJbnRlcnZhbCIsImV4dGVuZGVkIiwiZXh0ZW5kTG9jayIsIm1zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../core/dist/executor.js\n");

/***/ }),

/***/ "(rsc)/../core/dist/index.js":
/*!*****************************!*\
  !*** ../core/dist/index.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.JobExecutor = exports.Scheduler = exports.RedisStorageAdapter = exports.PostgresStorageAdapter = exports.SQLiteStorageAdapter = exports.MemoryStorageAdapter = exports.StorageError = exports.JobExecutionError = exports.CronxError = exports.Cronx = void 0;\nconst crypto_1 = __webpack_require__(/*! crypto */ \"crypto\");\nconst scheduler_js_1 = __webpack_require__(/*! ./scheduler.js */ \"(rsc)/../core/dist/scheduler.js\");\nconst executor_js_1 = __webpack_require__(/*! ./executor.js */ \"(rsc)/../core/dist/executor.js\");\nconst metrics_js_1 = __webpack_require__(/*! ./metrics.js */ \"(rsc)/../core/dist/metrics.js\");\nconst index_js_1 = __webpack_require__(/*! ./storage/index.js */ \"(rsc)/../core/dist/storage/index.js\");\nconst types_js_1 = __webpack_require__(/*! ./types.js */ \"(rsc)/../core/dist/types.js\");\nclass DefaultLogger {\n    info(message, meta) {\n        console.log(`[INFO] ${message}`, meta ? JSON.stringify(meta) : \"\");\n    }\n    warn(message, meta) {\n        console.warn(`[WARN] ${message}`, meta ? JSON.stringify(meta) : \"\");\n    }\n    error(message, meta) {\n        console.error(`[ERROR] ${message}`, meta ? JSON.stringify(meta) : \"\");\n    }\n    debug(message, meta) {\n        // Only log debug in development\n        if (true) {\n            console.debug(`[DEBUG] ${message}`, meta ? JSON.stringify(meta) : \"\");\n        }\n    }\n}\nclass Cronx {\n    constructor(config){\n        this.isStarted = false;\n        this.jobHandlers = new Map();\n        this.workerId = config.workerId || `cronx-${(0, crypto_1.randomUUID)()}`;\n        this.logger = config.logger || new DefaultLogger();\n        this.storage = typeof config.storage === \"string\" ? (0, index_js_1.createStorageAdapter)(config.storage) : config.storage;\n        this.scheduler = new scheduler_js_1.Scheduler(this.logger, config.timezone);\n        this.metrics = new metrics_js_1.MetricsCollector(config.metrics, this.logger);\n        this.executor = new executor_js_1.JobExecutor(this.storage, this.workerId, this.logger, this.metrics);\n        this.logger.info(\"Cronx instance created\", {\n            workerId: this.workerId,\n            timezone: config.timezone\n        });\n    }\n    /**\n     * Schedule a new cron job\n     */ async schedule(schedule, handler, options) {\n        if (!options.name) {\n            throw new types_js_1.CronxError(\"Job name is required\");\n        }\n        const now = new Date();\n        const job = {\n            name: options.name,\n            schedule,\n            handler,\n            options,\n            isActive: true,\n            isPaused: false,\n            createdAt: now,\n            updatedAt: now\n        };\n        // Store handler separately (not persisted)\n        this.jobHandlers.set(options.name, handler);\n        // Save job to storage\n        await this.storage.saveJob(job);\n        // Add to scheduler\n        this.scheduler.addJob(job);\n        // Record metrics\n        this.metrics.recordJobScheduled(options.name, this.workerId);\n        this.logger.info(`Job '${options.name}' scheduled`, {\n            job: options.name,\n            schedule,\n            retries: options.retries || 0,\n            backoff: options.backoff || \"fixed\"\n        });\n    }\n    /**\n     * Remove a scheduled job\n     */ async unschedule(name) {\n        const removed = this.scheduler.removeJob(name);\n        this.jobHandlers.delete(name);\n        if (removed) {\n            await this.storage.deleteJob(name);\n            this.logger.info(`Job '${name}' unscheduled`, {\n                job: name\n            });\n        }\n        return removed;\n    }\n    /**\n     * Get job information\n     */ async getJob(name) {\n        const job = await this.storage.getJob(name);\n        if (job && this.jobHandlers.has(name)) {\n            job.handler = this.jobHandlers.get(name);\n        }\n        return job;\n    }\n    /**\n     * List all jobs\n     */ async listJobs() {\n        const jobs = await this.storage.listJobs();\n        // Restore handlers\n        return jobs.map((job)=>{\n            if (this.jobHandlers.has(job.name)) {\n                job.handler = this.jobHandlers.get(job.name);\n            }\n            return job;\n        });\n    }\n    /**\n     * Get job run history\n     */ async getJobRuns(jobName, limit) {\n        return await this.storage.getJobRuns(jobName, limit);\n    }\n    /**\n     * Get job statistics\n     */ async getJobStats(jobName) {\n        return await this.storage.getJobStats(jobName);\n    }\n    /**\n     * Pause a job (stops scheduling new executions)\n     */ async pauseJob(name) {\n        const success = await this.storage.pauseJob(name);\n        if (success) {\n            // Update scheduler\n            const job = this.scheduler.getJob(name);\n            if (job) {\n                job.isPaused = true;\n                job.updatedAt = new Date();\n            }\n            this.logger.info(`Job '${name}' paused`, {\n                job: name\n            });\n        }\n        return success;\n    }\n    /**\n     * Resume a paused job\n     */ async resumeJob(name) {\n        const success = await this.storage.resumeJob(name);\n        if (success) {\n            // Update scheduler\n            const job = this.scheduler.getJob(name);\n            if (job) {\n                job.isPaused = false;\n                job.updatedAt = new Date();\n            }\n            this.logger.info(`Job '${name}' resumed`, {\n                job: name\n            });\n        }\n        return success;\n    }\n    /**\n     * Get upcoming run times for a job\n     */ getUpcomingRuns(jobName, count) {\n        return this.scheduler.getUpcomingRuns(jobName, count);\n    }\n    /**\n     * Manually trigger a job execution\n     */ async runJob(name) {\n        const job = await this.getJob(name);\n        if (!job) {\n            throw new types_js_1.CronxError(`Job '${name}' not found`);\n        }\n        this.logger.info(`Manually triggering job '${name}'`, {\n            job: name\n        });\n        return await this.executor.executeJob(job);\n    }\n    /**\n     * Start the cron scheduler\n     */ async start() {\n        if (this.isStarted) {\n            this.logger.warn(\"Cronx is already started\");\n            return;\n        }\n        try {\n            // Connect to storage\n            await this.storage.connect();\n            // Load existing jobs from storage\n            await this.loadJobsFromStorage();\n            // Start scheduler\n            this.scheduler.start();\n            this.isStarted = true;\n            this.logger.info(\"Cronx started successfully\", {\n                workerId: this.workerId\n            });\n        } catch (error) {\n            this.logger.error(`Failed to start Cronx: ${error}`, {\n                error: error instanceof Error ? error.message : String(error)\n            });\n            throw error;\n        }\n    }\n    /**\n     * Stop the cron scheduler\n     */ async stop() {\n        if (!this.isStarted) {\n            this.logger.warn(\"Cronx is not started\");\n            return;\n        }\n        try {\n            // Stop scheduler\n            this.scheduler.stop();\n            // Disconnect from storage\n            await this.storage.disconnect();\n            this.isStarted = false;\n            this.logger.info(\"Cronx stopped successfully\", {\n                workerId: this.workerId\n            });\n        } catch (error) {\n            this.logger.error(`Error stopping Cronx: ${error}`, {\n                error: error instanceof Error ? error.message : String(error)\n            });\n            throw error;\n        }\n    }\n    /**\n     * Check if Cronx is running\n     */ isRunning() {\n        return this.isStarted;\n    }\n    /**\n     * Get Cronx statistics\n     */ async getStats() {\n        const jobs = await this.listJobs();\n        return {\n            totalJobs: jobs.length,\n            activeJobs: jobs.filter((job)=>job.isActive && !job.isPaused).length,\n            pausedJobs: jobs.filter((job)=>job.isPaused).length,\n            workerId: this.workerId,\n            isRunning: this.isStarted\n        };\n    }\n    /**\n     * Get Prometheus metrics (if enabled)\n     */ async getMetrics() {\n        return await this.metrics.getMetrics();\n    }\n    async loadJobsFromStorage() {\n        try {\n            const storedJobs = await this.storage.listJobs();\n            this.logger.info(`Loading ${storedJobs.length} jobs from storage`);\n            for (const job of storedJobs){\n                // Jobs from storage won't have handlers, they need to be re-registered\n                // This is expected - handlers are not persisted\n                if (this.jobHandlers.has(job.name)) {\n                    job.handler = this.jobHandlers.get(job.name);\n                    this.scheduler.addJob(job);\n                } else {\n                    this.logger.warn(`Job '${job.name}' found in storage but no handler registered`, {\n                        job: job.name\n                    });\n                }\n            }\n        } catch (error) {\n            this.logger.error(`Failed to load jobs from storage: ${error}`, {\n                error: error instanceof Error ? error.message : String(error)\n            });\n            throw error;\n        }\n    }\n}\nexports.Cronx = Cronx;\n// Export types and classes\nvar types_js_2 = __webpack_require__(/*! ./types.js */ \"(rsc)/../core/dist/types.js\");\nObject.defineProperty(exports, \"CronxError\", ({\n    enumerable: true,\n    get: function() {\n        return types_js_2.CronxError;\n    }\n}));\nObject.defineProperty(exports, \"JobExecutionError\", ({\n    enumerable: true,\n    get: function() {\n        return types_js_2.JobExecutionError;\n    }\n}));\nObject.defineProperty(exports, \"StorageError\", ({\n    enumerable: true,\n    get: function() {\n        return types_js_2.StorageError;\n    }\n}));\nvar index_js_2 = __webpack_require__(/*! ./storage/index.js */ \"(rsc)/../core/dist/storage/index.js\");\nObject.defineProperty(exports, \"MemoryStorageAdapter\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_2.MemoryStorageAdapter;\n    }\n}));\nObject.defineProperty(exports, \"SQLiteStorageAdapter\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_2.SQLiteStorageAdapter;\n    }\n}));\nObject.defineProperty(exports, \"PostgresStorageAdapter\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_2.PostgresStorageAdapter;\n    }\n}));\nObject.defineProperty(exports, \"RedisStorageAdapter\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_2.RedisStorageAdapter;\n    }\n}));\nvar scheduler_js_2 = __webpack_require__(/*! ./scheduler.js */ \"(rsc)/../core/dist/scheduler.js\");\nObject.defineProperty(exports, \"Scheduler\", ({\n    enumerable: true,\n    get: function() {\n        return scheduler_js_2.Scheduler;\n    }\n}));\nvar executor_js_2 = __webpack_require__(/*! ./executor.js */ \"(rsc)/../core/dist/executor.js\");\nObject.defineProperty(exports, \"JobExecutor\", ({\n    enumerable: true,\n    get: function() {\n        return executor_js_2.JobExecutor;\n    }\n})); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtRQUNSO0lBQ0Y7O0FBelNGNkUsYUFBQSxHQUFBMUU7QUE0U0EsMkJBQTJCO0FBQzNCLElBQUEyRSxhQUFBN0YsbUJBQUFBLENBQUE7QUFRRThGLDhDQUFBO0lBQUFFLFlBQUE7SUFBQW5DLEtBQUE7UUFBQSxPQUFBZ0MsV0FBQXJELFVBQVU7SUFBQTtBQUFBO0FBQ1ZzRCxxREFBQTtJQUFBRSxZQUFBO0lBQUFuQyxLQUFBO1FBQUEsT0FBQWdDLFdBQUFJLGlCQUFpQjtJQUFBO0FBQUE7QUFDakJILGdEQUFBO0lBQUFFLFlBQUE7SUFBQW5DLEtBQUE7UUFBQSxPQUFBZ0MsV0FBQUssWUFBWTtJQUFBO0FBQUE7QUFHZCxJQUFBQyxhQUFBbkcsbUJBQUFBLENBQUE7QUFDRThGLHdEQUFBO0lBQUFFLFlBQUE7SUFBQW5DLEtBQUE7UUFBQSxPQUFBc0MsV0FBQUMsb0JBQW9CO0lBQUE7QUFBQTtBQUNwQk4sd0RBQUE7SUFBQUUsWUFBQTtJQUFBbkMsS0FBQTtRQUFBLE9BQUFzQyxXQUFBRSxvQkFBb0I7SUFBQTtBQUFBO0FBQ3BCUCwwREFBQTtJQUFBRSxZQUFBO0lBQUFuQyxLQUFBO1FBQUEsT0FBQXNDLFdBQUFHLHNCQUFzQjtJQUFBO0FBQUE7QUFDdEJSLHVEQUFBO0lBQUFFLFlBQUE7SUFBQW5DLEtBQUE7UUFBQSxPQUFBc0MsV0FBQUksbUJBQW1CO0lBQUE7QUFBQTtBQUdyQixJQUFBQyxpQkFBQXhHLG1CQUFBQSxDQUFBO0FBQVM4Riw2Q0FBQTtJQUFBRSxZQUFBO0lBQUFuQyxLQUFBO1FBQUEsT0FBQTJDLGVBQUExRSxTQUFTO0lBQUE7QUFBQTtBQUNsQixJQUFBMkUsZ0JBQUF6RyxtQkFBQUEsQ0FBQTtBQUFTOEYsK0NBQUE7SUFBQUUsWUFBQTtJQUFBbkMsS0FBQTtRQUFBLE9BQUE0QyxjQUFBdEUsV0FBVztJQUFBO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AcGx1czk5L2Nyb254LXVpLy4uL3NyYy9pbmRleC50cz81MmQ1Il0sIm5hbWVzIjpbImNyeXB0b18xIiwicmVxdWlyZSIsInNjaGVkdWxlcl9qc18xIiwiZXhlY3V0b3JfanNfMSIsIm1ldHJpY3NfanNfMSIsImluZGV4X2pzXzEiLCJ0eXBlc19qc18xIiwiRGVmYXVsdExvZ2dlciIsImluZm8iLCJtZXNzYWdlIiwibWV0YSIsImNvbnNvbGUiLCJsb2ciLCJKU09OIiwic3RyaW5naWZ5Iiwid2FybiIsImVycm9yIiwiZGVidWciLCJwcm9jZXNzIiwiQ3JvbngiLCJjb25zdHJ1Y3RvciIsImNvbmZpZyIsImlzU3RhcnRlZCIsImpvYkhhbmRsZXJzIiwiTWFwIiwid29ya2VySWQiLCJyYW5kb21VVUlEIiwibG9nZ2VyIiwic3RvcmFnZSIsImNyZWF0ZVN0b3JhZ2VBZGFwdGVyIiwic2NoZWR1bGVyIiwiU2NoZWR1bGVyIiwidGltZXpvbmUiLCJtZXRyaWNzIiwiTWV0cmljc0NvbGxlY3RvciIsImV4ZWN1dG9yIiwiSm9iRXhlY3V0b3IiLCJzY2hlZHVsZSIsImhhbmRsZXIiLCJvcHRpb25zIiwibmFtZSIsIkNyb254RXJyb3IiLCJub3ciLCJEYXRlIiwiam9iIiwiaXNBY3RpdmUiLCJpc1BhdXNlZCIsImNyZWF0ZWRBdCIsInVwZGF0ZWRBdCIsInNldCIsInNhdmVKb2IiLCJhZGRKb2IiLCJyZWNvcmRKb2JTY2hlZHVsZWQiLCJyZXRyaWVzIiwiYmFja29mZiIsInVuc2NoZWR1bGUiLCJyZW1vdmVkIiwicmVtb3ZlSm9iIiwiZGVsZXRlIiwiZGVsZXRlSm9iIiwiZ2V0Sm9iIiwiaGFzIiwiZ2V0IiwibGlzdEpvYnMiLCJqb2JzIiwibWFwIiwiZ2V0Sm9iUnVucyIsImpvYk5hbWUiLCJsaW1pdCIsImdldEpvYlN0YXRzIiwicGF1c2VKb2IiLCJzdWNjZXNzIiwicmVzdW1lSm9iIiwiZ2V0VXBjb21pbmdSdW5zIiwiY291bnQiLCJydW5Kb2IiLCJleGVjdXRlSm9iIiwic3RhcnQiLCJjb25uZWN0IiwibG9hZEpvYnNGcm9tU3RvcmFnZSIsIkVycm9yIiwiU3RyaW5nIiwic3RvcCIsImRpc2Nvbm5lY3QiLCJpc1J1bm5pbmciLCJnZXRTdGF0cyIsInRvdGFsSm9icyIsImxlbmd0aCIsImFjdGl2ZUpvYnMiLCJmaWx0ZXIiLCJwYXVzZWRKb2JzIiwiZ2V0TWV0cmljcyIsInN0b3JlZEpvYnMiLCJleHBvcnRzIiwidHlwZXNfanNfMiIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsIkpvYkV4ZWN1dGlvbkVycm9yIiwiU3RvcmFnZUVycm9yIiwiaW5kZXhfanNfMiIsIk1lbW9yeVN0b3JhZ2VBZGFwdGVyIiwiU1FMaXRlU3RvcmFnZUFkYXB0ZXIiLCJQb3N0Z3Jlc1N0b3JhZ2VBZGFwdGVyIiwiUmVkaXNTdG9yYWdlQWRhcHRlciIsInNjaGVkdWxlcl9qc18yIiwiZXhlY3V0b3JfanNfMiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../core/dist/index.js\n");

/***/ }),

/***/ "(rsc)/../core/dist/metrics.js":
/*!*******************************!*\
  !*** ../core/dist/metrics.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.MetricsCollector = void 0;\nconst prom_client_1 = __webpack_require__(/*! prom-client */ \"(rsc)/../../node_modules/prom-client/index.js\");\nclass MetricsCollector {\n    constructor(enabled = false, logger){\n        this.enabled = enabled;\n        this.logger = logger;\n        if (!enabled) {\n            // Create no-op metrics\n            this.jobsTotal = {\n                inc: ()=>{},\n                labels: ()=>({\n                        inc: ()=>{}\n                    })\n            };\n            this.jobsCompleted = {\n                inc: ()=>{},\n                labels: ()=>({\n                        inc: ()=>{}\n                    })\n            };\n            this.jobsFailed = {\n                inc: ()=>{},\n                labels: ()=>({\n                        inc: ()=>{}\n                    })\n            };\n            this.jobDuration = {\n                observe: ()=>{},\n                labels: ()=>({\n                        observe: ()=>{}\n                    })\n            };\n            this.activeJobs = {\n                set: ()=>{},\n                labels: ()=>({\n                        set: ()=>{}\n                    })\n            };\n            this.queueSize = {\n                set: ()=>{},\n                labels: ()=>({\n                        set: ()=>{}\n                    })\n            };\n            return;\n        }\n        // Total jobs scheduled\n        this.jobsTotal = new prom_client_1.Counter({\n            name: \"cronx_jobs_total\",\n            help: \"Total number of jobs scheduled\",\n            labelNames: [\n                \"job_name\",\n                \"worker_id\"\n            ]\n        });\n        // Completed jobs\n        this.jobsCompleted = new prom_client_1.Counter({\n            name: \"cronx_jobs_completed_total\",\n            help: \"Total number of jobs completed successfully\",\n            labelNames: [\n                \"job_name\",\n                \"worker_id\"\n            ]\n        });\n        // Failed jobs\n        this.jobsFailed = new prom_client_1.Counter({\n            name: \"cronx_jobs_failed_total\",\n            help: \"Total number of jobs that failed\",\n            labelNames: [\n                \"job_name\",\n                \"worker_id\",\n                \"error_type\"\n            ]\n        });\n        // Job execution duration\n        this.jobDuration = new prom_client_1.Histogram({\n            name: \"cronx_job_duration_seconds\",\n            help: \"Job execution duration in seconds\",\n            labelNames: [\n                \"job_name\",\n                \"worker_id\",\n                \"status\"\n            ],\n            buckets: [\n                0.1,\n                0.5,\n                1,\n                2,\n                5,\n                10,\n                30,\n                60,\n                300\n            ]\n        });\n        // Currently active jobs\n        this.activeJobs = new prom_client_1.Gauge({\n            name: \"cronx_active_jobs\",\n            help: \"Number of currently executing jobs\",\n            labelNames: [\n                \"worker_id\"\n            ]\n        });\n        // Queue size\n        this.queueSize = new prom_client_1.Gauge({\n            name: \"cronx_queue_size\",\n            help: \"Number of jobs waiting to be executed\",\n            labelNames: [\n                \"worker_id\"\n            ]\n        });\n        this.logger?.info(\"Prometheus metrics initialized\");\n    }\n    recordJobScheduled(jobName, workerId) {\n        if (!this.enabled) return;\n        this.jobsTotal.labels(jobName, workerId).inc();\n    }\n    recordJobStarted(jobName, workerId) {\n        if (!this.enabled) return;\n        this.activeJobs.labels(workerId).inc();\n    }\n    recordJobCompleted(jobName, workerId, duration) {\n        if (!this.enabled) return;\n        this.jobsCompleted.labels(jobName, workerId).inc();\n        this.jobDuration.labels(jobName, workerId, \"completed\").observe(duration / 1000);\n        this.activeJobs.labels(workerId).dec();\n    }\n    recordJobFailed(jobName, workerId, duration, errorType) {\n        if (!this.enabled) return;\n        this.jobsFailed.labels(jobName, workerId, errorType).inc();\n        this.jobDuration.labels(jobName, workerId, \"failed\").observe(duration / 1000);\n        this.activeJobs.labels(workerId).dec();\n    }\n    updateQueueSize(workerId, size) {\n        if (!this.enabled) return;\n        this.queueSize.labels(workerId).set(size);\n    }\n    async getMetrics() {\n        if (!this.enabled) return \"\";\n        return await prom_client_1.register.metrics();\n    }\n    clearMetrics() {\n        if (!this.enabled) return;\n        prom_client_1.register.clear();\n    }\n}\nexports.MetricsCollector = MetricsCollector; //# sourceMappingURL=metrics.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0csS0FBSztJQUNoQjs7QUE1R0ZDLHdCQUFBLEdBQUF0QyIsInNvdXJjZXMiOlsid2VicGFjazovL0BwbHVzOTkvY3JvbngtdWkvLi4vc3JjL21ldHJpY3MudHM/NWQ2ZSJdLCJuYW1lcyI6WyJwcm9tX2NsaWVudF8xIiwicmVxdWlyZSIsIk1ldHJpY3NDb2xsZWN0b3IiLCJjb25zdHJ1Y3RvciIsImVuYWJsZWQiLCJsb2dnZXIiLCJqb2JzVG90YWwiLCJpbmMiLCJsYWJlbHMiLCJqb2JzQ29tcGxldGVkIiwiam9ic0ZhaWxlZCIsImpvYkR1cmF0aW9uIiwib2JzZXJ2ZSIsImFjdGl2ZUpvYnMiLCJzZXQiLCJxdWV1ZVNpemUiLCJDb3VudGVyIiwibmFtZSIsImhlbHAiLCJsYWJlbE5hbWVzIiwiSGlzdG9ncmFtIiwiYnVja2V0cyIsIkdhdWdlIiwiaW5mbyIsInJlY29yZEpvYlNjaGVkdWxlZCIsImpvYk5hbWUiLCJ3b3JrZXJJZCIsInJlY29yZEpvYlN0YXJ0ZWQiLCJyZWNvcmRKb2JDb21wbGV0ZWQiLCJkdXJhdGlvbiIsImRlYyIsInJlY29yZEpvYkZhaWxlZCIsImVycm9yVHlwZSIsInVwZGF0ZVF1ZXVlU2l6ZSIsInNpemUiLCJnZXRNZXRyaWNzIiwicmVnaXN0ZXIiLCJtZXRyaWNzIiwiY2xlYXJNZXRyaWNzIiwiY2xlYXIiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../core/dist/metrics.js\n");

/***/ }),

/***/ "(rsc)/../core/dist/scheduler.js":
/*!*********************************!*\
  !*** ../core/dist/scheduler.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Scheduler = void 0;\nconst cron_parser_1 = __webpack_require__(/*! cron-parser */ \"(rsc)/../../node_modules/cron-parser/lib/parser.js\");\nclass Scheduler {\n    constructor(logger, timezone){\n        this.logger = logger;\n        this.timezone = timezone;\n        this.jobs = new Map();\n        this.timers = new Map();\n        this.isRunning = false;\n    }\n    addJob(job) {\n        this.jobs.set(job.name, job);\n        this.logger?.info(`Job '${job.name}' added to scheduler`, {\n            job: job.name,\n            schedule: job.schedule\n        });\n        if (this.isRunning && job.isActive && !job.isPaused) {\n            this.scheduleJob(job);\n        }\n    }\n    removeJob(name) {\n        const timer = this.timers.get(name);\n        if (timer) {\n            clearTimeout(timer);\n            this.timers.delete(name);\n        }\n        const removed = this.jobs.delete(name);\n        if (removed) {\n            this.logger?.info(`Job '${name}' removed from scheduler`, {\n                job: name\n            });\n        }\n        return removed;\n    }\n    getJob(name) {\n        return this.jobs.get(name);\n    }\n    listJobs() {\n        return Array.from(this.jobs.values());\n    }\n    start() {\n        if (this.isRunning) return;\n        this.isRunning = true;\n        this.logger?.info(\"Scheduler started\");\n        // Schedule all active jobs\n        for (const job of this.jobs.values()){\n            if (job.isActive) {\n                this.scheduleJob(job);\n            }\n        }\n    }\n    stop() {\n        if (!this.isRunning) return;\n        this.isRunning = false;\n        this.logger?.info(\"Scheduler stopped\");\n        // Clear all timers\n        for (const timer of this.timers.values()){\n            clearTimeout(timer);\n        }\n        this.timers.clear();\n    }\n    scheduleJob(job) {\n        try {\n            const cronExpression = (0, cron_parser_1.parseExpression)(job.schedule, {\n                tz: this.timezone\n            });\n            const nextRun = cronExpression.next().toDate();\n            job.nextRun = nextRun;\n            const delay = nextRun.getTime() - Date.now();\n            this.logger?.debug(`Scheduling job '${job.name}' to run in ${delay}ms`, {\n                job: job.name,\n                nextRun: nextRun.toISOString()\n            });\n            const timer = setTimeout(()=>{\n                this.executeJob(job);\n                // Reschedule for next execution\n                if (this.isRunning && job.isActive && !job.isPaused) {\n                    this.scheduleJob(job);\n                }\n            }, delay);\n            this.timers.set(job.name, timer);\n        } catch (error) {\n            this.logger?.error(`Failed to schedule job '${job.name}': ${error}`, {\n                job: job.name,\n                error: error instanceof Error ? error.message : String(error)\n            });\n        }\n    }\n    executeJob(job) {\n        // Check if job is paused before execution\n        if (job.isPaused) {\n            this.logger?.info(`Skipping paused job '${job.name}'`, {\n                job: job.name\n            });\n            return;\n        }\n        this.logger?.info(`Executing job '${job.name}'`, {\n            job: job.name\n        });\n        // Update last run time\n        job.lastRun = new Date();\n    // The actual execution will be handled by the executor\n    // This just triggers the job to be picked up by the execution engine\n    }\n    // Get next scheduled run time for a job\n    getNextRunTime(jobName) {\n        const job = this.jobs.get(jobName);\n        if (!job || !job.isActive) return null;\n        try {\n            const cronExpression = (0, cron_parser_1.parseExpression)(job.schedule, {\n                tz: this.timezone\n            });\n            return cronExpression.next().toDate();\n        } catch (error) {\n            this.logger?.error(`Failed to calculate next run time for job '${jobName}': ${error}`, {\n                job: jobName,\n                error: error instanceof Error ? error.message : String(error)\n            });\n            return null;\n        }\n    }\n    // Calculate multiple future run times\n    getUpcomingRuns(jobName, count = 5) {\n        const job = this.jobs.get(jobName);\n        if (!job || !job.isActive) return [];\n        try {\n            const cronExpression = (0, cron_parser_1.parseExpression)(job.schedule, {\n                tz: this.timezone\n            });\n            const runs = [];\n            for(let i = 0; i < count; i++){\n                runs.push(cronExpression.next().toDate());\n            }\n            return runs;\n        } catch (error) {\n            this.logger?.error(`Failed to calculate upcoming runs for job '${jobName}': ${error}`, {\n                job: jobName,\n                error: error instanceof Error ? error.message : String(error)\n            });\n            return [];\n        }\n    }\n}\nexports.Scheduler = Scheduler; //# sourceMappingURL=scheduler.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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T0g7O1lBRXpELE9BQU8sRUFBRTtRQUNYO0lBQ0Y7O0FBbEtGWSxpQkFBQSxHQUFBekQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AcGx1czk5L2Nyb254LXVpLy4uL3NyYy9zY2hlZHVsZXIudHM/ZGZjOCJdLCJuYW1lcyI6WyJjcm9uX3BhcnNlcl8xIiwicmVxdWlyZSIsIlNjaGVkdWxlciIsImNvbnN0cnVjdG9yIiwibG9nZ2VyIiwidGltZXpvbmUiLCJqb2JzIiwiTWFwIiwidGltZXJzIiwiaXNSdW5uaW5nIiwiYWRkSm9iIiwiam9iIiwic2V0IiwibmFtZSIsImluZm8iLCJzY2hlZHVsZSIsImlzQWN0aXZlIiwiaXNQYXVzZWQiLCJzY2hlZHVsZUpvYiIsInJlbW92ZUpvYiIsInRpbWVyIiwiZ2V0IiwiY2xlYXJUaW1lb3V0IiwiZGVsZXRlIiwicmVtb3ZlZCIsImdldEpvYiIsImxpc3RKb2JzIiwiQXJyYXkiLCJmcm9tIiwidmFsdWVzIiwic3RhcnQiLCJzdG9wIiwiY2xlYXIiLCJjcm9uRXhwcmVzc2lvbiIsInBhcnNlRXhwcmVzc2lvbiIsInR6IiwibmV4dFJ1biIsIm5leHQiLCJ0b0RhdGUiLCJkZWxheSIsImdldFRpbWUiLCJEYXRlIiwibm93IiwiZGVidWciLCJ0b0lTT1N0cmluZyIsInNldFRpbWVvdXQiLCJleGVjdXRlSm9iIiwiZXJyb3IiLCJFcnJvciIsIm1lc3NhZ2UiLCJTdHJpbmciLCJsYXN0UnVuIiwiZ2V0TmV4dFJ1blRpbWUiLCJqb2JOYW1lIiwiZ2V0VXBjb21pbmdSdW5zIiwiY291bnQiLCJydW5zIiwiaSIsInB1c2giLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../core/dist/scheduler.js\n");

/***/ }),

/***/ "(rsc)/../core/dist/storage/index.js":
/*!*************************************!*\
  !*** ../core/dist/storage/index.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.RedisStorageAdapter = exports.PostgresStorageAdapter = exports.SQLiteStorageAdapter = exports.MemoryStorageAdapter = void 0;\nexports.createStorageAdapter = createStorageAdapter;\nconst types_js_1 = __webpack_require__(/*! ../types.js */ \"(rsc)/../core/dist/types.js\");\nconst memory_js_1 = __webpack_require__(/*! ./memory.js */ \"(rsc)/../core/dist/storage/memory.js\");\nObject.defineProperty(exports, \"MemoryStorageAdapter\", ({\n    enumerable: true,\n    get: function() {\n        return memory_js_1.MemoryStorageAdapter;\n    }\n}));\nconst sqlite_js_1 = __webpack_require__(/*! ./sqlite.js */ \"(rsc)/../core/dist/storage/sqlite.js\");\nObject.defineProperty(exports, \"SQLiteStorageAdapter\", ({\n    enumerable: true,\n    get: function() {\n        return sqlite_js_1.SQLiteStorageAdapter;\n    }\n}));\nconst postgres_js_1 = __webpack_require__(/*! ./postgres.js */ \"(rsc)/../core/dist/storage/postgres.js\");\nObject.defineProperty(exports, \"PostgresStorageAdapter\", ({\n    enumerable: true,\n    get: function() {\n        return postgres_js_1.PostgresStorageAdapter;\n    }\n}));\nconst redis_js_1 = __webpack_require__(/*! ./redis.js */ \"(rsc)/../core/dist/storage/redis.js\");\nObject.defineProperty(exports, \"RedisStorageAdapter\", ({\n    enumerable: true,\n    get: function() {\n        return redis_js_1.RedisStorageAdapter;\n    }\n}));\nfunction createStorageAdapter(config) {\n    if (typeof config === \"object\") {\n        return config;\n    }\n    const url = new URL(config);\n    switch(url.protocol){\n        case \"memory:\":\n            return new memory_js_1.MemoryStorageAdapter();\n        case \"sqlite:\":\n            return new sqlite_js_1.SQLiteStorageAdapter(url.pathname);\n        case \"postgres:\":\n        case \"postgresql:\":\n            return new postgres_js_1.PostgresStorageAdapter(config);\n        case \"redis:\":\n        case \"rediss:\":\n            return new redis_js_1.RedisStorageAdapter(config);\n        default:\n            throw new types_js_1.StorageError(`Unsupported storage protocol: ${url.protocol}`);\n    }\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vY29yZS9kaXN0L3N0b3JhZ2UvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFRQUEsNEJBQUEsR0FBQUM7QUFSQSxNQUFBQyxhQUFBQyxtQkFBQUEsQ0FBQTtBQUNBLE1BQUFDLGNBQUFELG1CQUFBQSxDQUFBO0FBS1NFLHdEQUFBO0lBQUFFLFlBQUE7SUFBQUMsS0FBQTtRQUFBLE9BTEFKLFlBQUFLLG9CQUFvQjtJQUFBO0FBQUE7QUFDN0IsTUFBQUMsY0FBQVAsbUJBQUFBLENBQUE7QUFJK0JFLHdEQUFBO0lBQUFFLFlBQUE7SUFBQUMsS0FBQTtRQUFBLE9BSnRCRSxZQUFBQyxvQkFBb0I7SUFBQTtBQUFBO0FBQzdCLE1BQUFDLGdCQUFBVCxtQkFBQUEsQ0FBQTtBQUdxREUsMERBQUE7SUFBQUUsWUFBQTtJQUFBQyxLQUFBO1FBQUEsT0FINUNJLGNBQUFDLHNCQUFzQjtJQUFBO0FBQUE7QUFDL0IsTUFBQUMsYUFBQVgsbUJBQUFBLENBQUE7QUFFNkVFLHVEQUFBO0lBQUFFLFlBQUE7SUFBQUMsS0FBQTtRQUFBLE9BRnBFTSxXQUFBQyxtQkFBbUI7SUFBQTtBQUFBO0FBSTVCLFNBQWdCZCxxQkFBcUJlLE1BQStCO0lBQ2xFLElBQUksT0FBT0EsV0FBVyxVQUFVO1FBQzlCLE9BQU9BO0lBQ1Q7SUFFQSxNQUFNQyxNQUFNLElBQUlDLElBQUlGO0lBRXBCLE9BQVFDLElBQUlFLFFBQVE7UUFDbEIsS0FBSztZQUNILE9BQU8sSUFBSWYsWUFBQUssb0JBQW9CO1FBRWpDLEtBQUs7WUFDSCxPQUFPLElBQUlDLFlBQUFDLG9CQUFvQixDQUFDTSxJQUFJRyxRQUFRO1FBRTlDLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTyxJQUFJUixjQUFBQyxzQkFBc0IsQ0FBQ0c7UUFFcEMsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPLElBQUlGLFdBQUFDLG1CQUFtQixDQUFDQztRQUVqQztZQUNFLE1BQU0sSUFBSWQsV0FBQW1CLFlBQVksQ0FBQyxpQ0FBaUNKLElBQUlFLFFBQVEsRUFBRTtJQUMxRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHBsdXM5OS9jcm9ueC11aS8uLi8uLi9zcmMvc3RvcmFnZS9pbmRleC50cz9jODQ1Il0sIm5hbWVzIjpbImV4cG9ydHMiLCJjcmVhdGVTdG9yYWdlQWRhcHRlciIsInR5cGVzX2pzXzEiLCJyZXF1aXJlIiwibWVtb3J5X2pzXzEiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJnZXQiLCJNZW1vcnlTdG9yYWdlQWRhcHRlciIsInNxbGl0ZV9qc18xIiwiU1FMaXRlU3RvcmFnZUFkYXB0ZXIiLCJwb3N0Z3Jlc19qc18xIiwiUG9zdGdyZXNTdG9yYWdlQWRhcHRlciIsInJlZGlzX2pzXzEiLCJSZWRpc1N0b3JhZ2VBZGFwdGVyIiwiY29uZmlnIiwidXJsIiwiVVJMIiwicHJvdG9jb2wiLCJwYXRobmFtZSIsIlN0b3JhZ2VFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../core/dist/storage/index.js\n");

/***/ }),

/***/ "(rsc)/../core/dist/storage/memory.js":
/*!**************************************!*\
  !*** ../core/dist/storage/memory.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.MemoryStorageAdapter = void 0;\nconst types_js_1 = __webpack_require__(/*! ../types.js */ \"(rsc)/../core/dist/types.js\");\nclass MemoryStorageAdapter {\n    constructor(){\n        this.jobs = new Map();\n        this.jobRuns = new Map();\n        this.locks = new Map();\n    }\n    async connect() {\n    // No-op for memory storage\n    }\n    async disconnect() {\n        this.jobs.clear();\n        this.jobRuns.clear();\n        this.locks.clear();\n    }\n    async saveJob(job) {\n        this.jobs.set(job.name, {\n            ...job\n        });\n    }\n    async pauseJob(name) {\n        const job = this.jobs.get(name);\n        if (job) {\n            job.isPaused = true;\n            job.updatedAt = new Date();\n            return true;\n        }\n        return false;\n    }\n    async resumeJob(name) {\n        const job = this.jobs.get(name);\n        if (job) {\n            job.isPaused = false;\n            job.updatedAt = new Date();\n            return true;\n        }\n        return false;\n    }\n    async getJob(name) {\n        const job = this.jobs.get(name);\n        return job ? {\n            ...job\n        } : null;\n    }\n    async listJobs() {\n        return Array.from(this.jobs.values()).map((job)=>({\n                ...job\n            }));\n    }\n    async deleteJob(name) {\n        return this.jobs.delete(name);\n    }\n    async saveJobRun(run) {\n        this.jobRuns.set(run.id, {\n            ...run\n        });\n    }\n    async getJobRun(id) {\n        const run = this.jobRuns.get(id);\n        return run ? {\n            ...run\n        } : null;\n    }\n    async getJobRuns(jobName, limit) {\n        const runs = Array.from(this.jobRuns.values()).filter((run)=>run.jobName === jobName).sort((a, b)=>(b.startTime?.getTime() || 0) - (a.startTime?.getTime() || 0));\n        return limit ? runs.slice(0, limit) : runs;\n    }\n    async getJobStats(jobName) {\n        if (jobName) {\n            const runs = await this.getJobRuns(jobName);\n            const successful = runs.filter((r)=>r.status === \"completed\").length;\n            const failed = runs.filter((r)=>r.status === \"failed\").length;\n            const durations = runs.filter((r)=>r.startTime && r.endTime).map((r)=>r.endTime.getTime() - r.startTime.getTime());\n            const job = this.jobs.get(jobName);\n            return {\n                totalRuns: runs.length,\n                successfulRuns: successful,\n                failedRuns: failed,\n                averageDuration: durations.length > 0 ? durations.reduce((a, b)=>a + b, 0) / durations.length : 0,\n                lastRun: job?.lastRun,\n                nextRun: job?.nextRun\n            };\n        } else {\n            const allRuns = Array.from(this.jobRuns.values());\n            const successful = allRuns.filter((r)=>r.status === \"completed\").length;\n            const failed = allRuns.filter((r)=>r.status === \"failed\").length;\n            const durations = allRuns.filter((r)=>r.startTime && r.endTime).map((r)=>r.endTime.getTime() - r.startTime.getTime());\n            return {\n                totalRuns: allRuns.length,\n                successfulRuns: successful,\n                failedRuns: failed,\n                averageDuration: durations.length > 0 ? durations.reduce((a, b)=>a + b, 0) / durations.length : 0\n            };\n        }\n    }\n    async acquireLock(jobName, workerId, ttl) {\n        try {\n            // Clean up expired locks first\n            this.cleanupExpiredLocks();\n            const existing = this.locks.get(jobName);\n            const now = new Date();\n            // Check if lock exists and is not expired\n            if (existing && existing.expiresAt > now) {\n                return existing.workerId === workerId;\n            }\n            // Acquire new lock\n            this.locks.set(jobName, {\n                workerId,\n                expiresAt: new Date(now.getTime() + ttl)\n            });\n            return true;\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to acquire lock: ${error}`, error);\n        }\n    }\n    async releaseLock(jobName, workerId) {\n        const existing = this.locks.get(jobName);\n        if (existing && existing.workerId === workerId) {\n            this.locks.delete(jobName);\n            return true;\n        }\n        return false;\n    }\n    async extendLock(jobName, workerId, ttl) {\n        try {\n            this.cleanupExpiredLocks();\n            const existing = this.locks.get(jobName);\n            const now = new Date();\n            if (existing && existing.workerId === workerId && existing.expiresAt > now) {\n                this.locks.set(jobName, {\n                    workerId,\n                    expiresAt: new Date(now.getTime() + ttl)\n                });\n                return true;\n            }\n            return false;\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to extend lock: ${error}`, error);\n        }\n    }\n    cleanupExpiredLocks() {\n        const now = new Date();\n        for (const [jobName, lock] of this.locks.entries()){\n            if (lock.expiresAt <= now) {\n                this.locks.delete(jobName);\n            }\n        }\n    }\n}\nexports.MemoryStorageAdapter = MemoryStorageAdapter; //# sourceMappingURL=memory.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUM3RCxJQUFJO1lBQ0YsSUFBSSxDQUFDQyxtQkFBbUI7WUFFeEIsTUFBTUMsV0FBVyxJQUFJLENBQUN6RCxLQUFLLENBQUNTLEdBQUcsQ0FBQ2tCO1lBQ2hDLE1BQU0rQixNQUFNLElBQUk5QztZQUVoQixJQUFJNkMsWUFBWUEsU0FBU0gsUUFBUSxLQUFLQSxZQUFZRyxTQUFTRSxTQUFTLEdBQUdELEtBQUs7Z0JBQzFFLElBQUksQ0FBQzFELEtBQUssQ0FBQ00sR0FBRyxDQUFDcUIsU0FBUztvQkFDdEIyQjtvQkFDQUssV0FBVyxJQUFJL0MsS0FBSzhDLElBQUl2QixPQUFPLEtBQUtvQjs7Z0JBRXRDLE9BQU87WUFDVDtZQUVBLE9BQU87UUFDVCxFQUFFLE9BQU9LLE9BQU87WUFDZCxNQUFNLElBQUluRSxXQUFBb0UsWUFBWSxDQUFDLDBCQUEwQkQsTUFBSyxDQUFFLEVBQUVBO1FBQzVEO0lBQ0Y7SUFFUUosc0JBQW1CO1FBQ3pCLE1BQU1FLE1BQU0sSUFBSTlDO1FBQ2hCLEtBQUssTUFBTSxDQUFDZSxTQUFTcUMsS0FBSyxJQUFJLElBQUksQ0FBQ2hFLEtBQUssQ0FBQ2lFLE9BQU8sR0FBSTtZQUNsRCxJQUFJRCxLQUFLTCxTQUFTLElBQUlELEtBQUs7Z0JBQ3pCLElBQUksQ0FBQzFELEtBQUssQ0FBQ3FCLE1BQU0sQ0FBQ007WUFDcEI7UUFDRjtJQUNGOztBQXpLRnVDLDRCQUFBLEdBQUF2RSIsInNvdXJjZXMiOlsid2VicGFjazovL0BwbHVzOTkvY3JvbngtdWkvLi4vLi4vc3JjL3N0b3JhZ2UvbWVtb3J5LnRzPzA0YmIiXSwibmFtZXMiOlsidHlwZXNfanNfMSIsInJlcXVpcmUiLCJNZW1vcnlTdG9yYWdlQWRhcHRlciIsImNvbnN0cnVjdG9yIiwiam9icyIsIk1hcCIsImpvYlJ1bnMiLCJsb2NrcyIsImNvbm5lY3QiLCJkaXNjb25uZWN0IiwiY2xlYXIiLCJzYXZlSm9iIiwiam9iIiwic2V0IiwibmFtZSIsInBhdXNlSm9iIiwiZ2V0IiwiaXNQYXVzZWQiLCJ1cGRhdGVkQXQiLCJEYXRlIiwicmVzdW1lSm9iIiwiZ2V0Sm9iIiwibGlzdEpvYnMiLCJBcnJheSIsImZyb20iLCJ2YWx1ZXMiLCJtYXAiLCJkZWxldGVKb2IiLCJkZWxldGUiLCJzYXZlSm9iUnVuIiwicnVuIiwiaWQiLCJnZXRKb2JSdW4iLCJnZXRKb2JSdW5zIiwiam9iTmFtZSIsImxpbWl0IiwicnVucyIsImZpbHRlciIsInNvcnQiLCJhIiwiYiIsInN0YXJ0VGltZSIsImdldFRpbWUiLCJzbGljZSIsImdldEpvYlN0YXRzIiwic3VjY2Vzc2Z1bCIsInIiLCJzdGF0dXMiLCJsZW5ndGgiLCJmYWlsZWQiLCJkdXJhdGlvbnMiLCJlbmRUaW1lIiwidG90YWxSdW5zIiwic3VjY2Vzc2Z1bFJ1bnMiLCJmYWlsZWRSdW5zIiwiYXZlcmFnZUR1cmF0aW9uIiwicmVkdWNlIiwibGFzdFJ1biIsIm5leHRSdW4iLCJhbGxSdW5zIiwiYWNxdWlyZUxvY2siLCJ3b3JrZXJJZCIsInR0bCIsImNsZWFudXBFeHBpcmVkTG9ja3MiLCJleGlzdGluZyIsIm5vdyIsImV4cGlyZXNBdCIsImVycm9yIiwiU3RvcmFnZUVycm9yIiwicmVsZWFzZUxvY2siLCJleHRlbmRMb2NrIiwibG9jayIsImVudHJpZXMiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../core/dist/storage/memory.js\n");

/***/ }),

/***/ "(rsc)/../core/dist/storage/postgres.js":
/*!****************************************!*\
  !*** ../core/dist/storage/postgres.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.PostgresStorageAdapter = void 0;\nconst pg_1 = __webpack_require__(/*! pg */ \"pg\");\nconst types_js_1 = __webpack_require__(/*! ../types.js */ \"(rsc)/../core/dist/types.js\");\nclass PostgresStorageAdapter {\n    constructor(connectionString){\n        this.connectionString = connectionString;\n        this.client = null;\n    }\n    async connect() {\n        try {\n            this.client = new pg_1.Client({\n                connectionString: this.connectionString\n            });\n            await this.client.connect();\n            await this.initTables();\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to connect to PostgreSQL: ${error}`, error);\n        }\n    }\n    async disconnect() {\n        if (this.client) {\n            await this.client.end();\n            this.client = null;\n        }\n    }\n    async initTables() {\n        if (!this.client) throw new types_js_1.StorageError(\"Database not connected\");\n        try {\n            // Jobs table\n            await this.client.query(`\n        CREATE TABLE IF NOT EXISTS jobs (\n          name TEXT PRIMARY KEY,\n          schedule TEXT NOT NULL,\n          options JSONB NOT NULL,\n          is_active BOOLEAN NOT NULL DEFAULT true,\n          created_at TIMESTAMPTZ NOT NULL,\n          updated_at TIMESTAMPTZ NOT NULL,\n          last_run TIMESTAMPTZ,\n          next_run TIMESTAMPTZ\n        )\n      `);\n            // Job runs table\n            await this.client.query(`\n        CREATE TABLE IF NOT EXISTS job_runs (\n          id TEXT PRIMARY KEY,\n          job_name TEXT NOT NULL REFERENCES jobs(name) ON DELETE CASCADE,\n          status TEXT NOT NULL,\n          start_time TIMESTAMPTZ,\n          end_time TIMESTAMPTZ,\n          error TEXT,\n          result JSONB,\n          attempt INTEGER NOT NULL\n        )\n      `);\n            // Locks table for clustering\n            await this.client.query(`\n        CREATE TABLE IF NOT EXISTS locks (\n          job_name TEXT PRIMARY KEY,\n          worker_id TEXT NOT NULL,\n          expires_at TIMESTAMPTZ NOT NULL\n        )\n      `);\n            // Indexes\n            await this.client.query(`CREATE INDEX IF NOT EXISTS idx_job_runs_job_name ON job_runs (job_name)`);\n            await this.client.query(`CREATE INDEX IF NOT EXISTS idx_job_runs_start_time ON job_runs (start_time)`);\n            await this.client.query(`CREATE INDEX IF NOT EXISTS idx_locks_expires_at ON locks (expires_at)`);\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to initialize tables: ${error}`, error);\n        }\n    }\n    async saveJob(job) {\n        if (!this.client) throw new types_js_1.StorageError(\"Database not connected\");\n        try {\n            await this.client.query(`\n        INSERT INTO jobs (name, schedule, options, is_active, created_at, updated_at, last_run, next_run)\n        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\n        ON CONFLICT (name) DO UPDATE SET\n          schedule = EXCLUDED.schedule,\n          options = EXCLUDED.options,\n          is_active = EXCLUDED.is_active,\n          updated_at = EXCLUDED.updated_at,\n          last_run = EXCLUDED.last_run,\n          next_run = EXCLUDED.next_run\n      `, [\n                job.name,\n                job.schedule,\n                JSON.stringify(job.options),\n                job.isActive,\n                job.createdAt,\n                job.updatedAt,\n                job.lastRun || null,\n                job.nextRun || null\n            ]);\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to save job: ${error}`, error);\n        }\n    }\n    async getJob(name) {\n        if (!this.client) throw new types_js_1.StorageError(\"Database not connected\");\n        try {\n            const result = await this.client.query(\"SELECT * FROM jobs WHERE name = $1\", [\n                name\n            ]);\n            if (result.rows.length === 0) return null;\n            const row = result.rows[0];\n            return {\n                name: row.name,\n                schedule: row.schedule,\n                handler: ()=>Promise.resolve(),\n                options: row.options,\n                isActive: row.is_active,\n                isPaused: row.is_paused || false,\n                createdAt: new Date(row.created_at),\n                updatedAt: new Date(row.updated_at),\n                lastRun: row.last_run ? new Date(row.last_run) : undefined,\n                nextRun: row.next_run ? new Date(row.next_run) : undefined\n            };\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to get job: ${error}`, error);\n        }\n    }\n    async listJobs() {\n        if (!this.client) throw new types_js_1.StorageError(\"Database not connected\");\n        try {\n            const result = await this.client.query(\"SELECT * FROM jobs ORDER BY created_at\");\n            return result.rows.map((row)=>({\n                    name: row.name,\n                    schedule: row.schedule,\n                    handler: ()=>Promise.resolve(),\n                    options: row.options,\n                    isActive: row.is_active,\n                    isPaused: row.is_paused || false,\n                    createdAt: new Date(row.created_at),\n                    updatedAt: new Date(row.updated_at),\n                    lastRun: row.last_run ? new Date(row.last_run) : undefined,\n                    nextRun: row.next_run ? new Date(row.next_run) : undefined\n                }));\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to list jobs: ${error}`, error);\n        }\n    }\n    async deleteJob(name) {\n        if (!this.client) throw new types_js_1.StorageError(\"Database not connected\");\n        try {\n            const result = await this.client.query(\"DELETE FROM jobs WHERE name = $1\", [\n                name\n            ]);\n            return (result.rowCount || 0) > 0;\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to delete job: ${error}`, error);\n        }\n    }\n    async pauseJob(name) {\n        if (!this.client) throw new types_js_1.StorageError(\"Database not connected\");\n        try {\n            const result = await this.client.query(\"UPDATE jobs SET is_paused = true, updated_at = $1 WHERE name = $2\", [\n                new Date(),\n                name\n            ]);\n            return (result.rowCount || 0) > 0;\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to pause job: ${error}`, error);\n        }\n    }\n    async resumeJob(name) {\n        if (!this.client) throw new types_js_1.StorageError(\"Database not connected\");\n        try {\n            const result = await this.client.query(\"UPDATE jobs SET is_paused = false, updated_at = $1 WHERE name = $2\", [\n                new Date(),\n                name\n            ]);\n            return (result.rowCount || 0) > 0;\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to resume job: ${error}`, error);\n        }\n    }\n    async getJobStats(jobName) {\n        if (!this.client) throw new types_js_1.StorageError(\"Database not connected\");\n        try {\n            if (jobName) {\n                // Get stats for specific job\n                const runsQuery = `\n          SELECT COUNT(*) as total,\n                 SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as successful,\n                 SUM(CASE WHEN status = 'failed' THEN 1 ELSE 0 END) as failed,\n                 AVG(CASE WHEN start_time IS NOT NULL AND end_time IS NOT NULL \n                     THEN EXTRACT(EPOCH FROM (end_time - start_time)) * 1000 \n                     ELSE NULL END) as avg_duration\n          FROM job_runs WHERE job_name = $1\n        `;\n                const statsResult = await this.client.query(runsQuery, [\n                    jobName\n                ]);\n                const stats = statsResult.rows[0];\n                const jobQuery = \"SELECT last_run, next_run FROM jobs WHERE name = $1\";\n                const jobResult = await this.client.query(jobQuery, [\n                    jobName\n                ]);\n                const jobInfo = jobResult.rows[0];\n                return {\n                    totalRuns: parseInt(stats.total) || 0,\n                    successfulRuns: parseInt(stats.successful) || 0,\n                    failedRuns: parseInt(stats.failed) || 0,\n                    averageDuration: parseFloat(stats.avg_duration) || 0,\n                    lastRun: jobInfo?.last_run ? new Date(jobInfo.last_run) : undefined,\n                    nextRun: jobInfo?.next_run ? new Date(jobInfo.next_run) : undefined\n                };\n            } else {\n                // Get overall stats\n                const runsQuery = `\n          SELECT COUNT(*) as total,\n                 SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as successful,\n                 SUM(CASE WHEN status = 'failed' THEN 1 ELSE 0 END) as failed,\n                 AVG(CASE WHEN start_time IS NOT NULL AND end_time IS NOT NULL \n                     THEN EXTRACT(EPOCH FROM (end_time - start_time)) * 1000 \n                     ELSE NULL END) as avg_duration\n          FROM job_runs\n        `;\n                const statsResult = await this.client.query(runsQuery);\n                const stats = statsResult.rows[0];\n                return {\n                    totalRuns: parseInt(stats.total) || 0,\n                    successfulRuns: parseInt(stats.successful) || 0,\n                    failedRuns: parseInt(stats.failed) || 0,\n                    averageDuration: parseFloat(stats.avg_duration) || 0\n                };\n            }\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to get job stats: ${error}`, error);\n        }\n    }\n    async saveJobRun(run) {\n        if (!this.client) throw new types_js_1.StorageError(\"Database not connected\");\n        try {\n            await this.client.query(`\n        INSERT INTO job_runs (id, job_name, status, start_time, end_time, error, result, attempt)\n        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\n        ON CONFLICT (id) DO UPDATE SET\n          status = EXCLUDED.status,\n          start_time = EXCLUDED.start_time,\n          end_time = EXCLUDED.end_time,\n          error = EXCLUDED.error,\n          result = EXCLUDED.result,\n          attempt = EXCLUDED.attempt\n      `, [\n                run.id,\n                run.jobName,\n                run.status,\n                run.startTime || null,\n                run.endTime || null,\n                run.error || null,\n                run.result ? JSON.stringify(run.result) : null,\n                run.attempt\n            ]);\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to save job run: ${error}`, error);\n        }\n    }\n    async getJobRun(id) {\n        if (!this.client) throw new types_js_1.StorageError(\"Database not connected\");\n        try {\n            const result = await this.client.query(\"SELECT * FROM job_runs WHERE id = $1\", [\n                id\n            ]);\n            if (result.rows.length === 0) return null;\n            const row = result.rows[0];\n            return {\n                id: row.id,\n                jobName: row.job_name,\n                status: row.status,\n                startTime: row.start_time ? new Date(row.start_time) : undefined,\n                endTime: row.end_time ? new Date(row.end_time) : undefined,\n                error: row.error || undefined,\n                result: row.result || undefined,\n                attempt: row.attempt\n            };\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to get job run: ${error}`, error);\n        }\n    }\n    async getJobRuns(jobName, limit) {\n        if (!this.client) throw new types_js_1.StorageError(\"Database not connected\");\n        try {\n            const sql = `\n        SELECT * FROM job_runs \n        WHERE job_name = $1 \n        ORDER BY start_time DESC\n        ${limit ? \"LIMIT $2\" : \"\"}\n      `;\n            const params = limit ? [\n                jobName,\n                limit\n            ] : [\n                jobName\n            ];\n            const result = await this.client.query(sql, params);\n            return result.rows.map((row)=>({\n                    id: row.id,\n                    jobName: row.job_name,\n                    status: row.status,\n                    startTime: row.start_time ? new Date(row.start_time) : undefined,\n                    endTime: row.end_time ? new Date(row.end_time) : undefined,\n                    error: row.error || undefined,\n                    result: row.result || undefined,\n                    attempt: row.attempt\n                }));\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to get job runs: ${error}`, error);\n        }\n    }\n    async acquireLock(jobName, workerId, ttl) {\n        if (!this.client) throw new types_js_1.StorageError(\"Database not connected\");\n        try {\n            const now = new Date();\n            const expiresAt = new Date(now.getTime() + ttl);\n            // Clean up expired locks\n            await this.client.query(\"DELETE FROM locks WHERE expires_at < $1\", [\n                now\n            ]);\n            // Try to acquire lock\n            const result = await this.client.query(`\n        INSERT INTO locks (job_name, worker_id, expires_at)\n        VALUES ($1, $2, $3)\n        ON CONFLICT (job_name) DO UPDATE SET\n          worker_id = EXCLUDED.worker_id,\n          expires_at = EXCLUDED.expires_at\n        WHERE locks.worker_id = $2 OR locks.expires_at < $4\n        RETURNING job_name\n      `, [\n                jobName,\n                workerId,\n                expiresAt,\n                now\n            ]);\n            return (result.rowCount || 0) > 0;\n        } catch (error) {\n            // If constraint violation, lock is held by another worker\n            return false;\n        }\n    }\n    async releaseLock(jobName, workerId) {\n        if (!this.client) throw new types_js_1.StorageError(\"Database not connected\");\n        try {\n            const result = await this.client.query(\"DELETE FROM locks WHERE job_name = $1 AND worker_id = $2\", [\n                jobName,\n                workerId\n            ]);\n            return (result.rowCount || 0) > 0;\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to release lock: ${error}`, error);\n        }\n    }\n    async extendLock(jobName, workerId, ttl) {\n        if (!this.client) throw new types_js_1.StorageError(\"Database not connected\");\n        try {\n            const expiresAt = new Date(Date.now() + ttl);\n            const result = await this.client.query(`\n        UPDATE locks \n        SET expires_at = $1 \n        WHERE job_name = $2 AND worker_id = $3\n      `, [\n                expiresAt,\n                jobName,\n                workerId\n            ]);\n            return (result.rowCount || 0) > 0;\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to extend lock: ${error}`, error);\n        }\n    }\n}\nexports.PostgresStorageAdapter = PostgresStorageAdapter; //# sourceMappingURL=postgres.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vY29yZS9kaXN0L3N0b3JhZ2UvcG9zdGdyZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxNQUFBQSxPQUFBQyxtQkFBQUEsQ0FBQTtBQUNBLE1BQUFDLGFBQUFELG1CQUFBQSxDQUFBO0FBRUEsTUFBYUU7SUFHWEMsWUFBb0JDLGdCQUF3QjtRQUF4QixLQUFBQSxnQkFBZ0IsR0FBaEJBO1FBRlosS0FBQUMsTUFBTSxHQUFrQjtJQUVlO0lBRS9DLE1BQU1DLFVBQU87UUFDWCxJQUFJO1lBQ0YsSUFBSSxDQUFDRCxNQUFNLEdBQUcsSUFBSU4sS0FBQVEsTUFBTSxDQUFDO2dCQUFFSCxrQkFBa0IsSUFBSSxDQUFDQSxnQkFBZ0I7WUFBQTtZQUNsRSxNQUFNLElBQUksQ0FBQ0MsTUFBTSxDQUFDQyxPQUFPO1lBQ3pCLE1BQU0sSUFBSSxDQUFDRSxVQUFVO1FBQ3ZCLEVBQUUsT0FBT0MsT0FBTztZQUNkLE1BQU0sSUFBSVIsV0FBQVMsWUFBWSxDQUFDLG9DQUFvQ0QsTUFBSyxDQUFFLEVBQUVBO1FBQ3RFO0lBQ0Y7SUFFQSxNQUFNRSxhQUFVO1FBQ2QsSUFBSSxJQUFJLENBQUNOLE1BQU0sRUFBRTtZQUNmLE1BQU0sSUFBSSxDQUFDQSxNQUFNLENBQUNPLEdBQUc7WUFDckIsSUFBSSxDQUFDUCxNQUFNLEdBQUc7UUFDaEI7SUFDRjtJQUVRLE1BQU1HLGFBQVU7UUFDdEIsSUFBSSxDQUFDLElBQUksQ0FBQ0gsTUFBTSxFQUFFLE1BQU0sSUFBSUosV0FBQVMsWUFBWSxDQUFDO1FBRXpDLElBQUk7WUFDRixhQUFhO1lBQ2IsTUFBTSxJQUFJLENBQUNMLE1BQU0sQ0FBQ1EsS0FBSyxDQUFDOzs7Ozs7Ozs7OztPQVd2QjtZQUVELGlCQUFpQjtZQUNqQixNQUFNLElBQUksQ0FBQ1IsTUFBTSxDQUFDUSxLQUFLLENBQUM7Ozs7Ozs7Ozs7O09BV3ZCO1lBRUQsNkJBQTZCO1lBQzdCLE1BQU0sSUFBSSxDQUFDUixNQUFNLENBQUNRLEtBQUssQ0FBQzs7Ozs7O09B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Y3JvbngtdWkvLi4vLi4vc3JjL3N0b3JhZ2UvcG9zdGdyZXMudHM/OWFkYyJdLCJuYW1lcyI6WyJwZ18xIiwicmVxdWlyZSIsInR5cGVzX2pzXzEiLCJQb3N0Z3Jlc1N0b3JhZ2VBZGFwdGVyIiwiY29uc3RydWN0b3IiLCJjb25uZWN0aW9uU3RyaW5nIiwiY2xpZW50IiwiY29ubmVjdCIsIkNsaWVudCIsImluaXRUYWJsZXMiLCJlcnJvciIsIlN0b3JhZ2VFcnJvciIsImRpc2Nvbm5lY3QiLCJlbmQiLCJxdWVyeSIsInNhdmVKb2IiLCJqb2IiLCJuYW1lIiwic2NoZWR1bGUiLCJKU09OIiwic3RyaW5naWZ5Iiwib3B0aW9ucyIsImlzQWN0aXZlIiwiY3JlYXRlZEF0IiwidXBkYXRlZEF0IiwibGFzdFJ1biIsIm5leHRSdW4iLCJnZXRKb2IiLCJyZXN1bHQiLCJyb3dzIiwibGVuZ3RoIiwicm93IiwiaGFuZGxlciIsIlByb21pc2UiLCJyZXNvbHZlIiwiaXNfYWN0aXZlIiwiaXNQYXVzZWQiLCJpc19wYXVzZWQiLCJEYXRlIiwiY3JlYXRlZF9hdCIsInVwZGF0ZWRfYXQiLCJsYXN0X3J1biIsInVuZGVmaW5lZCIsIm5leHRfcnVuIiwibGlzdEpvYnMiLCJtYXAiLCJkZWxldGVKb2IiLCJyb3dDb3VudCIsInBhdXNlSm9iIiwicmVzdW1lSm9iIiwiZ2V0Sm9iU3RhdHMiLCJqb2JOYW1lIiwicnVuc1F1ZXJ5Iiwic3RhdHNSZXN1bHQiLCJzdGF0cyIsImpvYlF1ZXJ5Iiwiam9iUmVzdWx0Iiwiam9iSW5mbyIsInRvdGFsUnVucyIsInBhcnNlSW50IiwidG90YWwiLCJzdWNjZXNzZnVsUnVucyIsInN1Y2Nlc3NmdWwiLCJmYWlsZWRSdW5zIiwiZmFpbGVkIiwiYXZlcmFnZUR1cmF0aW9uIiwicGFyc2VGbG9hdCIsImF2Z19kdXJhdGlvbiIsInNhdmVKb2JSdW4iLCJydW4iLCJpZCIsInN0YXR1cyIsInN0YXJ0VGltZSIsImVuZFRpbWUiLCJhdHRlbXB0IiwiZ2V0Sm9iUnVuIiwiam9iX25hbWUiLCJzdGFydF90aW1lIiwiZW5kX3RpbWUiLCJnZXRKb2JSdW5zIiwibGltaXQiLCJzcWwiLCJwYXJhbXMiLCJhY3F1aXJlTG9jayIsIndvcmtlcklkIiwidHRsIiwibm93IiwiZXhwaXJlc0F0IiwiZ2V0VGltZSIsInJlbGVhc2VMb2NrIiwiZXh0ZW5kTG9jayIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../core/dist/storage/postgres.js\n");

/***/ }),

/***/ "(rsc)/../core/dist/storage/redis.js":
/*!*************************************!*\
  !*** ../core/dist/storage/redis.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.RedisStorageAdapter = void 0;\nconst redis_1 = __webpack_require__(/*! redis */ \"(rsc)/../../node_modules/redis/dist/index.js\");\nconst types_js_1 = __webpack_require__(/*! ../types.js */ \"(rsc)/../core/dist/types.js\");\nclass RedisStorageAdapter {\n    constructor(connectionString){\n        this.connectionString = connectionString;\n        this.client = null;\n    }\n    async connect() {\n        try {\n            this.client = (0, redis_1.createClient)({\n                url: this.connectionString\n            });\n            await this.client.connect();\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to connect to Redis: ${error}`, error);\n        }\n    }\n    async disconnect() {\n        if (this.client) {\n            await this.client.disconnect();\n            this.client = null;\n        }\n    }\n    getJobKey(name) {\n        return `cronx:job:${name}`;\n    }\n    getJobRunKey(id) {\n        return `cronx:run:${id}`;\n    }\n    getJobRunsKey(jobName) {\n        return `cronx:runs:${jobName}`;\n    }\n    getLockKey(jobName) {\n        return `cronx:lock:${jobName}`;\n    }\n    async saveJob(job) {\n        if (!this.client) throw new types_js_1.StorageError(\"Redis client not connected\");\n        try {\n            const jobData = {\n                name: job.name,\n                schedule: job.schedule,\n                options: JSON.stringify(job.options),\n                isActive: job.isActive.toString(),\n                isPaused: job.isPaused.toString(),\n                createdAt: job.createdAt.toISOString(),\n                updatedAt: job.updatedAt.toISOString(),\n                lastRun: job.lastRun?.toISOString() || \"\",\n                nextRun: job.nextRun?.toISOString() || \"\"\n            };\n            await this.client.hSet(this.getJobKey(job.name), jobData);\n            await this.client.sAdd(\"cronx:jobs\", job.name);\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to save job: ${error}`, error);\n        }\n    }\n    async getJob(name) {\n        if (!this.client) throw new types_js_1.StorageError(\"Redis client not connected\");\n        try {\n            const jobData = await this.client.hGetAll(this.getJobKey(name));\n            if (Object.keys(jobData).length === 0) return null;\n            return {\n                name: jobData.name,\n                schedule: jobData.schedule,\n                handler: ()=>Promise.resolve(),\n                options: JSON.parse(jobData.options),\n                isActive: jobData.isActive === \"true\",\n                isPaused: jobData.isPaused === \"true\",\n                createdAt: new Date(jobData.createdAt),\n                updatedAt: new Date(jobData.updatedAt),\n                lastRun: jobData.lastRun && jobData.lastRun !== \"\" ? new Date(jobData.lastRun) : undefined,\n                nextRun: jobData.nextRun && jobData.nextRun !== \"\" ? new Date(jobData.nextRun) : undefined\n            };\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to get job: ${error}`, error);\n        }\n    }\n    async listJobs() {\n        if (!this.client) throw new types_js_1.StorageError(\"Redis client not connected\");\n        try {\n            const jobNames = await this.client.sMembers(\"cronx:jobs\");\n            const jobs = [];\n            for (const name of jobNames){\n                const job = await this.getJob(name);\n                if (job) jobs.push(job);\n            }\n            return jobs.sort((a, b)=>a.createdAt.getTime() - b.createdAt.getTime());\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to list jobs: ${error}`, error);\n        }\n    }\n    async deleteJob(name) {\n        if (!this.client) throw new types_js_1.StorageError(\"Redis client not connected\");\n        try {\n            const deleted = await this.client.del(this.getJobKey(name));\n            await this.client.sRem(\"cronx:jobs\", name);\n            // Clean up job runs\n            const runIds = await this.client.lRange(this.getJobRunsKey(name), 0, -1);\n            if (runIds.length > 0) {\n                const runKeys = runIds.map((id)=>this.getJobRunKey(id));\n                await this.client.del(runKeys);\n                await this.client.del(this.getJobRunsKey(name));\n            }\n            return deleted > 0;\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to delete job: ${error}`, error);\n        }\n    }\n    async pauseJob(name) {\n        if (!this.client) throw new types_js_1.StorageError(\"Redis client not connected\");\n        try {\n            const jobKey = this.getJobKey(name);\n            await this.client.hSet(jobKey, \"isPaused\", \"true\");\n            await this.client.hSet(jobKey, \"updatedAt\", new Date().toISOString());\n            return true;\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to pause job: ${error}`, error);\n        }\n    }\n    async resumeJob(name) {\n        if (!this.client) throw new types_js_1.StorageError(\"Redis client not connected\");\n        try {\n            const jobKey = this.getJobKey(name);\n            await this.client.hSet(jobKey, \"isPaused\", \"false\");\n            await this.client.hSet(jobKey, \"updatedAt\", new Date().toISOString());\n            return true;\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to resume job: ${error}`, error);\n        }\n    }\n    async getJobStats(jobName) {\n        if (!this.client) throw new types_js_1.StorageError(\"Redis client not connected\");\n        try {\n            if (jobName) {\n                // Get stats for specific job\n                const runIds = await this.client.lRange(this.getJobRunsKey(jobName), 0, -1);\n                let totalRuns = 0;\n                let successfulRuns = 0;\n                let failedRuns = 0;\n                let totalDuration = 0;\n                let durationCount = 0;\n                for (const runId of runIds){\n                    const runData = await this.client.hGetAll(this.getJobRunKey(runId));\n                    if (Object.keys(runData).length > 0) {\n                        totalRuns++;\n                        if (runData.status === \"completed\") {\n                            successfulRuns++;\n                        } else if (runData.status === \"failed\") {\n                            failedRuns++;\n                        }\n                        if (runData.startTime && runData.endTime && runData.startTime !== \"\" && runData.endTime !== \"\") {\n                            const startTime = new Date(runData.startTime).getTime();\n                            const endTime = new Date(runData.endTime).getTime();\n                            if (!isNaN(startTime) && !isNaN(endTime)) {\n                                totalDuration += endTime - startTime;\n                                durationCount++;\n                            }\n                        }\n                    }\n                }\n                // Get job info for last_run and next_run\n                const jobData = await this.client.hGetAll(this.getJobKey(jobName));\n                return {\n                    totalRuns,\n                    successfulRuns,\n                    failedRuns,\n                    averageDuration: durationCount > 0 ? totalDuration / durationCount : 0,\n                    lastRun: jobData.lastRun && jobData.lastRun !== \"\" ? new Date(jobData.lastRun) : undefined,\n                    nextRun: jobData.nextRun && jobData.nextRun !== \"\" ? new Date(jobData.nextRun) : undefined\n                };\n            } else {\n                // Get overall stats across all jobs\n                const jobNames = await this.client.sMembers(\"cronx:jobs\");\n                let totalRuns = 0;\n                let successfulRuns = 0;\n                let failedRuns = 0;\n                let totalDuration = 0;\n                let durationCount = 0;\n                for (const jobName of jobNames){\n                    const runIds = await this.client.lRange(this.getJobRunsKey(jobName), 0, -1);\n                    for (const runId of runIds){\n                        const runData = await this.client.hGetAll(this.getJobRunKey(runId));\n                        if (Object.keys(runData).length > 0) {\n                            totalRuns++;\n                            if (runData.status === \"completed\") {\n                                successfulRuns++;\n                            } else if (runData.status === \"failed\") {\n                                failedRuns++;\n                            }\n                            if (runData.startTime && runData.endTime && runData.startTime !== \"\" && runData.endTime !== \"\") {\n                                const startTime = new Date(runData.startTime).getTime();\n                                const endTime = new Date(runData.endTime).getTime();\n                                if (!isNaN(startTime) && !isNaN(endTime)) {\n                                    totalDuration += endTime - startTime;\n                                    durationCount++;\n                                }\n                            }\n                        }\n                    }\n                }\n                return {\n                    totalRuns,\n                    successfulRuns,\n                    failedRuns,\n                    averageDuration: durationCount > 0 ? totalDuration / durationCount : 0\n                };\n            }\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to get job stats: ${error}`, error);\n        }\n    }\n    async saveJobRun(run) {\n        if (!this.client) throw new types_js_1.StorageError(\"Redis client not connected\");\n        try {\n            const runData = {\n                id: run.id,\n                jobName: run.jobName,\n                status: run.status,\n                startTime: run.startTime?.toISOString() || \"\",\n                endTime: run.endTime?.toISOString() || \"\",\n                error: run.error || \"\",\n                result: run.result ? JSON.stringify(run.result) : \"\",\n                attempt: run.attempt.toString()\n            };\n            await this.client.hSet(this.getJobRunKey(run.id), runData);\n            await this.client.lPush(this.getJobRunsKey(run.jobName), run.id);\n            // Keep only last 100 runs\n            await this.client.lTrim(this.getJobRunsKey(run.jobName), 0, 99);\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to save job run: ${error}`, error);\n        }\n    }\n    async getJobRun(id) {\n        if (!this.client) throw new types_js_1.StorageError(\"Redis client not connected\");\n        try {\n            const runData = await this.client.hGetAll(this.getJobRunKey(id));\n            if (Object.keys(runData).length === 0) return null;\n            return {\n                id: runData.id,\n                jobName: runData.jobName,\n                status: runData.status,\n                startTime: runData.startTime && runData.startTime !== \"\" ? new Date(runData.startTime) : undefined,\n                endTime: runData.endTime && runData.endTime !== \"\" ? new Date(runData.endTime) : undefined,\n                error: runData.error && runData.error !== \"\" ? runData.error : undefined,\n                result: runData.result && runData.result !== \"\" ? JSON.parse(runData.result) : undefined,\n                attempt: parseInt(runData.attempt)\n            };\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to get job run: ${error}`, error);\n        }\n    }\n    async getJobRuns(jobName, limit) {\n        if (!this.client) throw new types_js_1.StorageError(\"Redis client not connected\");\n        try {\n            const runIds = await this.client.lRange(this.getJobRunsKey(jobName), 0, limit ? limit - 1 : -1);\n            const runs = [];\n            for (const id of runIds){\n                const run = await this.getJobRun(id);\n                if (run) runs.push(run);\n            }\n            return runs;\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to get job runs: ${error}`, error);\n        }\n    }\n    async acquireLock(jobName, workerId, ttl) {\n        if (!this.client) throw new types_js_1.StorageError(\"Redis client not connected\");\n        try {\n            const lockKey = this.getLockKey(jobName);\n            const result = await this.client.set(lockKey, workerId, {\n                PX: ttl,\n                NX: true // Only set if key doesn't exist\n            });\n            return result === \"OK\";\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to acquire lock: ${error}`, error);\n        }\n    }\n    async releaseLock(jobName, workerId) {\n        if (!this.client) throw new types_js_1.StorageError(\"Redis client not connected\");\n        try {\n            const lockKey = this.getLockKey(jobName);\n            // Use Lua script to atomically check and delete\n            const script = `\n        if redis.call(\"GET\", KEYS[1]) == ARGV[1] then\n          return redis.call(\"DEL\", KEYS[1])\n        else\n          return 0\n        end\n      `;\n            const result = await this.client.eval(script, {\n                keys: [\n                    lockKey\n                ],\n                arguments: [\n                    workerId\n                ]\n            });\n            return result === 1;\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to release lock: ${error}`, error);\n        }\n    }\n    async extendLock(jobName, workerId, ttl) {\n        if (!this.client) throw new types_js_1.StorageError(\"Redis client not connected\");\n        try {\n            const lockKey = this.getLockKey(jobName);\n            // Use Lua script to atomically check owner and extend TTL\n            const script = `\n        if redis.call(\"GET\", KEYS[1]) == ARGV[1] then\n          return redis.call(\"PEXPIRE\", KEYS[1], ARGV[2])\n        else\n          return 0\n        end\n      `;\n            const result = await this.client.eval(script, {\n                keys: [\n                    lockKey\n                ],\n                arguments: [\n                    workerId,\n                    ttl.toString()\n                ]\n            });\n            return result === 1;\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to extend lock: ${error}`, error);\n        }\n    }\n}\nexports.RedisStorageAdapter = RedisStorageAdapter; //# sourceMappingURL=redis.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QixTQUFTLE1BQU0sSUFBSSxDQUFDN0UsTUFBTSxDQUFDK0YsSUFBSSxDQUFDRCxRQUFRO2dCQUM1QzVELE1BQU07b0JBQUN1RDtpQkFBUTtnQkFDZk8sV0FBVztvQkFBQ1Q7aUJBQVM7O1lBR3ZCLE9BQU9WLFdBQVc7UUFDcEIsRUFBRSxPQUFPekUsT0FBTztZQUNkLE1BQU0sSUFBSVIsV0FBQVMsWUFBWSxDQUFDLDJCQUEyQkQsTUFBSyxDQUFFLEVBQUVBO1FBQzdEO0lBQ0Y7SUFFQSxNQUFNNkYsV0FBV3JGLE9BQWUsRUFBRTJFLFFBQWdCLEVBQUVDLEdBQVc7UUFDN0QsSUFBSSxDQUFDLElBQUksQ0FBQ3hGLE1BQU0sRUFBRSxNQUFNLElBQUlKLFdBQUFTLFlBQVksQ0FBQztRQUV6QyxJQUFJO1lBQ0YsTUFBTW9GLFVBQVUsSUFBSSxDQUFDNUUsVUFBVSxDQUFDRDtZQUVoQywwREFBMEQ7WUFDMUQsTUFBTWtGLFNBQVM7Ozs7OztPQU1kO1lBRUQsTUFBTWpCLFNBQVMsTUFBTSxJQUFJLENBQUM3RSxNQUFNLENBQUMrRixJQUFJLENBQUNELFFBQVE7Z0JBQzVDNUQsTUFBTTtvQkFBQ3VEO2lCQUFRO2dCQUNmTyxXQUFXO29CQUFDVDtvQkFBVUMsSUFBSWxFLFFBQVE7aUJBQUc7O1lBR3ZDLE9BQU91RCxXQUFXO1FBQ3BCLEVBQUUsT0FBT3pFLE9BQU87WUFDZCxNQUFNLElBQUlSLFdBQUFTLFlBQVksQ0FBQywwQkFBMEJELE1BQUssQ0FBRSxFQUFFQTtRQUM1RDtJQUNGOztBQTdYRjhGLDJCQUFBLEdBQUFyRyIsInNvdXJjZXMiOlsid2VicGFjazovL0BwbHVzOTkvY3JvbngtdWkvLi4vLi4vc3JjL3N0b3JhZ2UvcmVkaXMudHM/NzI0MyJdLCJuYW1lcyI6WyJyZWRpc18xIiwicmVxdWlyZSIsInR5cGVzX2pzXzEiLCJSZWRpc1N0b3JhZ2VBZGFwdGVyIiwiY29uc3RydWN0b3IiLCJjb25uZWN0aW9uU3RyaW5nIiwiY2xpZW50IiwiY29ubmVjdCIsImNyZWF0ZUNsaWVudCIsInVybCIsImVycm9yIiwiU3RvcmFnZUVycm9yIiwiZGlzY29ubmVjdCIsImdldEpvYktleSIsIm5hbWUiLCJnZXRKb2JSdW5LZXkiLCJpZCIsImdldEpvYlJ1bnNLZXkiLCJqb2JOYW1lIiwiZ2V0TG9ja0tleSIsInNhdmVKb2IiLCJqb2IiLCJqb2JEYXRhIiwic2NoZWR1bGUiLCJvcHRpb25zIiwiSlNPTiIsInN0cmluZ2lmeSIsImlzQWN0aXZlIiwidG9TdHJpbmciLCJpc1BhdXNlZCIsImNyZWF0ZWRBdCIsInRvSVNPU3RyaW5nIiwidXBkYXRlZEF0IiwibGFzdFJ1biIsIm5leHRSdW4iLCJoU2V0Iiwic0FkZCIsImdldEpvYiIsImhHZXRBbGwiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwiaGFuZGxlciIsIlByb21pc2UiLCJyZXNvbHZlIiwicGFyc2UiLCJEYXRlIiwidW5kZWZpbmVkIiwibGlzdEpvYnMiLCJqb2JOYW1lcyIsInNNZW1iZXJzIiwiam9icyIsInB1c2giLCJzb3J0IiwiYSIsImIiLCJnZXRUaW1lIiwiZGVsZXRlSm9iIiwiZGVsZXRlZCIsImRlbCIsInNSZW0iLCJydW5JZHMiLCJsUmFuZ2UiLCJydW5LZXlzIiwibWFwIiwicGF1c2VKb2IiLCJqb2JLZXkiLCJyZXN1bWVKb2IiLCJnZXRKb2JTdGF0cyIsInRvdGFsUnVucyIsInN1Y2Nlc3NmdWxSdW5zIiwiZmFpbGVkUnVucyIsInRvdGFsRHVyYXRpb24iLCJkdXJhdGlvbkNvdW50IiwicnVuSWQiLCJydW5EYXRhIiwic3RhdHVzIiwic3RhcnRUaW1lIiwiZW5kVGltZSIsImlzTmFOIiwiYXZlcmFnZUR1cmF0aW9uIiwic2F2ZUpvYlJ1biIsInJ1biIsInJlc3VsdCIsImF0dGVtcHQiLCJsUHVzaCIsImxUcmltIiwiZ2V0Sm9iUnVuIiwicGFyc2VJbnQiLCJnZXRKb2JSdW5zIiwibGltaXQiLCJydW5zIiwiYWNxdWlyZUxvY2siLCJ3b3JrZXJJZCIsInR0bCIsImxvY2tLZXkiLCJzZXQiLCJQWCIsIk5YIiwicmVsZWFzZUxvY2siLCJzY3JpcHQiLCJldmFsIiwiYXJndW1lbnRzIiwiZXh0ZW5kTG9jayIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../core/dist/storage/redis.js\n");

/***/ }),

/***/ "(rsc)/../core/dist/storage/sqlite.js":
/*!**************************************!*\
  !*** ../core/dist/storage/sqlite.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.SQLiteStorageAdapter = void 0;\nconst better_sqlite3_1 = __importDefault(__webpack_require__(/*! better-sqlite3 */ \"better-sqlite3\"));\nconst types_js_1 = __webpack_require__(/*! ../types.js */ \"(rsc)/../core/dist/types.js\");\nclass SQLiteStorageAdapter {\n    constructor(dbPath){\n        this.dbPath = dbPath;\n        this.db = null;\n    }\n    async connect() {\n        try {\n            this.db = new better_sqlite3_1.default(this.dbPath);\n            this.initTables();\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to connect to SQLite database: ${error}`, error);\n        }\n    }\n    async disconnect() {\n        if (this.db) {\n            this.db.close();\n            this.db = null;\n        }\n    }\n    initTables() {\n        if (!this.db) throw new types_js_1.StorageError(\"Database not connected\");\n        // Jobs table\n        this.db.exec(`\n      CREATE TABLE IF NOT EXISTS jobs (\n        name TEXT PRIMARY KEY,\n        schedule TEXT NOT NULL,\n        options TEXT NOT NULL,\n        is_active INTEGER NOT NULL DEFAULT 1,\n        is_paused INTEGER NOT NULL DEFAULT 0,\n        created_at DATETIME NOT NULL,\n        updated_at DATETIME NOT NULL,\n        last_run DATETIME,\n        next_run DATETIME\n      )\n    `);\n        // Job runs table\n        this.db.exec(`\n      CREATE TABLE IF NOT EXISTS job_runs (\n        id TEXT PRIMARY KEY,\n        job_name TEXT NOT NULL,\n        status TEXT NOT NULL,\n        start_time DATETIME,\n        end_time DATETIME,\n        error TEXT,\n        result TEXT,\n        attempt INTEGER NOT NULL,\n        FOREIGN KEY (job_name) REFERENCES jobs (name) ON DELETE CASCADE\n      )\n    `);\n        // Locks table for clustering\n        this.db.exec(`\n      CREATE TABLE IF NOT EXISTS locks (\n        job_name TEXT PRIMARY KEY,\n        worker_id TEXT NOT NULL,\n        expires_at DATETIME NOT NULL\n      )\n    `);\n        // Indexes\n        this.db.exec(`CREATE INDEX IF NOT EXISTS idx_job_runs_job_name ON job_runs (job_name)`);\n        this.db.exec(`CREATE INDEX IF NOT EXISTS idx_job_runs_start_time ON job_runs (start_time)`);\n        this.db.exec(`CREATE INDEX IF NOT EXISTS idx_locks_expires_at ON locks (expires_at)`);\n    }\n    async saveJob(job) {\n        if (!this.db) throw new types_js_1.StorageError(\"Database not connected\");\n        try {\n            const stmt = this.db.prepare(`\n        INSERT OR REPLACE INTO jobs \n        (name, schedule, options, is_active, is_paused, created_at, updated_at, last_run, next_run)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n      `);\n            stmt.run(job.name, job.schedule, JSON.stringify(job.options), job.isActive ? 1 : 0, job.isPaused ? 1 : 0, job.createdAt.toISOString(), job.updatedAt.toISOString(), job.lastRun?.toISOString() || null, job.nextRun?.toISOString() || null);\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to save job: ${error}`, error);\n        }\n    }\n    async getJob(name) {\n        if (!this.db) throw new types_js_1.StorageError(\"Database not connected\");\n        try {\n            const stmt = this.db.prepare(\"SELECT * FROM jobs WHERE name = ?\");\n            const row = stmt.get(name);\n            if (!row) return null;\n            return {\n                name: row.name,\n                schedule: row.schedule,\n                handler: ()=>Promise.resolve(),\n                options: JSON.parse(row.options),\n                isActive: row.is_active === 1,\n                isPaused: row.is_paused === 1,\n                createdAt: new Date(row.created_at),\n                updatedAt: new Date(row.updated_at),\n                lastRun: row.last_run ? new Date(row.last_run) : undefined,\n                nextRun: row.next_run ? new Date(row.next_run) : undefined\n            };\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to get job: ${error}`, error);\n        }\n    }\n    async listJobs() {\n        if (!this.db) throw new types_js_1.StorageError(\"Database not connected\");\n        try {\n            const stmt = this.db.prepare(\"SELECT * FROM jobs ORDER BY created_at\");\n            const rows = stmt.all();\n            return rows.map((row)=>({\n                    name: row.name,\n                    schedule: row.schedule,\n                    handler: ()=>Promise.resolve(),\n                    options: JSON.parse(row.options),\n                    isActive: row.is_active === 1,\n                    isPaused: row.is_paused === 1,\n                    createdAt: new Date(row.created_at),\n                    updatedAt: new Date(row.updated_at),\n                    lastRun: row.last_run ? new Date(row.last_run) : undefined,\n                    nextRun: row.next_run ? new Date(row.next_run) : undefined\n                }));\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to list jobs: ${error}`, error);\n        }\n    }\n    async deleteJob(name) {\n        if (!this.db) throw new types_js_1.StorageError(\"Database not connected\");\n        try {\n            const stmt = this.db.prepare(\"DELETE FROM jobs WHERE name = ?\");\n            const result = stmt.run(name);\n            return result.changes > 0;\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to delete job: ${error}`, error);\n        }\n    }\n    async pauseJob(name) {\n        if (!this.db) throw new types_js_1.StorageError(\"Database not connected\");\n        try {\n            const stmt = this.db.prepare(\"UPDATE jobs SET is_paused = 1, updated_at = ? WHERE name = ?\");\n            const result = stmt.run(new Date().toISOString(), name);\n            return result.changes > 0;\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to pause job: ${error}`, error);\n        }\n    }\n    async resumeJob(name) {\n        if (!this.db) throw new types_js_1.StorageError(\"Database not connected\");\n        try {\n            const stmt = this.db.prepare(\"UPDATE jobs SET is_paused = 0, updated_at = ? WHERE name = ?\");\n            const result = stmt.run(new Date().toISOString(), name);\n            return result.changes > 0;\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to resume job: ${error}`, error);\n        }\n    }\n    async saveJobRun(run) {\n        if (!this.db) throw new types_js_1.StorageError(\"Database not connected\");\n        try {\n            const stmt = this.db.prepare(`\n        INSERT OR REPLACE INTO job_runs \n        (id, job_name, status, start_time, end_time, error, result, attempt)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n      `);\n            stmt.run(run.id, run.jobName, run.status, run.startTime?.toISOString() || null, run.endTime?.toISOString() || null, run.error || null, run.result ? JSON.stringify(run.result) : null, run.attempt);\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to save job run: ${error}`, error);\n        }\n    }\n    async getJobRun(id) {\n        if (!this.db) throw new types_js_1.StorageError(\"Database not connected\");\n        try {\n            const stmt = this.db.prepare(\"SELECT * FROM job_runs WHERE id = ?\");\n            const row = stmt.get(id);\n            if (!row) return null;\n            return {\n                id: row.id,\n                jobName: row.job_name,\n                status: row.status,\n                startTime: row.start_time ? new Date(row.start_time) : undefined,\n                endTime: row.end_time ? new Date(row.end_time) : undefined,\n                error: row.error || undefined,\n                result: row.result ? JSON.parse(row.result) : undefined,\n                attempt: row.attempt\n            };\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to get job run: ${error}`, error);\n        }\n    }\n    async getJobRuns(jobName, limit) {\n        if (!this.db) throw new types_js_1.StorageError(\"Database not connected\");\n        try {\n            const sql = `\n        SELECT * FROM job_runs \n        WHERE job_name = ? \n        ORDER BY start_time DESC\n        ${limit ? \"LIMIT ?\" : \"\"}\n      `;\n            const stmt = this.db.prepare(sql);\n            const rows = limit ? stmt.all(jobName, limit) : stmt.all(jobName);\n            return rows.map((row)=>({\n                    id: row.id,\n                    jobName: row.job_name,\n                    status: row.status,\n                    startTime: row.start_time ? new Date(row.start_time) : undefined,\n                    endTime: row.end_time ? new Date(row.end_time) : undefined,\n                    error: row.error || undefined,\n                    result: row.result ? JSON.parse(row.result) : undefined,\n                    attempt: row.attempt\n                }));\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to get job runs: ${error}`, error);\n        }\n    }\n    async getJobStats(jobName) {\n        if (!this.db) throw new types_js_1.StorageError(\"Database not connected\");\n        try {\n            if (jobName) {\n                // Get stats for specific job\n                const runsStmt = this.db.prepare(`\n          SELECT COUNT(*) as total,\n                 SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as successful,\n                 SUM(CASE WHEN status = 'failed' THEN 1 ELSE 0 END) as failed,\n                 AVG(CASE WHEN start_time IS NOT NULL AND end_time IS NOT NULL \n                     THEN (julianday(end_time) - julianday(start_time)) * 86400000 \n                     ELSE NULL END) as avg_duration\n          FROM job_runs WHERE job_name = ?\n        `);\n                const stats = runsStmt.get(jobName);\n                const jobStmt = this.db.prepare(\"SELECT last_run, next_run FROM jobs WHERE name = ?\");\n                const jobInfo = jobStmt.get(jobName);\n                return {\n                    totalRuns: stats.total || 0,\n                    successfulRuns: stats.successful || 0,\n                    failedRuns: stats.failed || 0,\n                    averageDuration: stats.avg_duration || 0,\n                    lastRun: jobInfo?.last_run ? new Date(jobInfo.last_run) : undefined,\n                    nextRun: jobInfo?.next_run ? new Date(jobInfo.next_run) : undefined\n                };\n            } else {\n                // Get overall stats\n                const runsStmt = this.db.prepare(`\n          SELECT COUNT(*) as total,\n                 SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as successful,\n                 SUM(CASE WHEN status = 'failed' THEN 1 ELSE 0 END) as failed,\n                 AVG(CASE WHEN start_time IS NOT NULL AND end_time IS NOT NULL \n                     THEN (julianday(end_time) - julianday(start_time)) * 86400000 \n                     ELSE NULL END) as avg_duration\n          FROM job_runs\n        `);\n                const stats = runsStmt.get();\n                return {\n                    totalRuns: stats.total || 0,\n                    successfulRuns: stats.successful || 0,\n                    failedRuns: stats.failed || 0,\n                    averageDuration: stats.avg_duration || 0\n                };\n            }\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to get job stats: ${error}`, error);\n        }\n    }\n    async acquireLock(jobName, workerId, ttl) {\n        if (!this.db) throw new types_js_1.StorageError(\"Database not connected\");\n        try {\n            const now = new Date();\n            const expiresAt = new Date(now.getTime() + ttl);\n            // Clean up expired locks\n            this.db.prepare(\"DELETE FROM locks WHERE expires_at < ?\").run(now.toISOString());\n            // Try to acquire lock\n            const stmt = this.db.prepare(`\n        INSERT INTO locks (job_name, worker_id, expires_at)\n        VALUES (?, ?, ?)\n        ON CONFLICT(job_name) DO UPDATE SET\n          worker_id = excluded.worker_id,\n          expires_at = excluded.expires_at\n        WHERE worker_id = excluded.worker_id OR expires_at < ?\n      `);\n            const result = stmt.run(jobName, workerId, expiresAt.toISOString(), now.toISOString());\n            return result.changes > 0;\n        } catch (error) {\n            // If constraint violation, lock is held by another worker\n            return false;\n        }\n    }\n    async releaseLock(jobName, workerId) {\n        if (!this.db) throw new types_js_1.StorageError(\"Database not connected\");\n        try {\n            const stmt = this.db.prepare(\"DELETE FROM locks WHERE job_name = ? AND worker_id = ?\");\n            const result = stmt.run(jobName, workerId);\n            return result.changes > 0;\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to release lock: ${error}`, error);\n        }\n    }\n    async extendLock(jobName, workerId, ttl) {\n        if (!this.db) throw new types_js_1.StorageError(\"Database not connected\");\n        try {\n            const expiresAt = new Date(Date.now() + ttl);\n            const stmt = this.db.prepare(`\n        UPDATE locks \n        SET expires_at = ? \n        WHERE job_name = ? AND worker_id = ?\n      `);\n            const result = stmt.run(expiresAt.toISOString(), jobName, workerId);\n            return result.changes > 0;\n        } catch (error) {\n            throw new types_js_1.StorageError(`Failed to extend lock: ${error}`, error);\n        }\n    }\n}\nexports.SQLiteStorageAdapter = SQLiteStorageAdapter; //# sourceMappingURL=sqlite.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUUsTUFBTSxJQUFJSixXQUFBUyxZQUFZLENBQUM7UUFFckMsSUFBSTtZQUNGLE1BQU1NLE9BQU8sSUFBSSxDQUFDWCxFQUFFLENBQUNZLE9BQU8sQ0FBQztZQUM3QixNQUFNa0MsU0FBU25DLEtBQUtFLEdBQUcsQ0FBQ3VDLFNBQVMwQjtZQUNqQyxPQUFPaEMsT0FBT0MsT0FBTyxHQUFHO1FBQzFCLEVBQUUsT0FBTzNDLE9BQU87WUFDZCxNQUFNLElBQUlSLFdBQUFTLFlBQVksQ0FBQywyQkFBMkJELE1BQUssQ0FBRSxFQUFFQTtRQUM3RDtJQUNGO0lBRUEsTUFBTWdGLFdBQVdoQyxPQUFlLEVBQUUwQixRQUFnQixFQUFFQyxHQUFXO1FBQzdELElBQUksQ0FBQyxJQUFJLENBQUMvRSxFQUFFLEVBQUUsTUFBTSxJQUFJSixXQUFBUyxZQUFZLENBQUM7UUFFckMsSUFBSTtZQUNGLE1BQU00RSxZQUFZLElBQUk5QyxLQUFLQSxLQUFLNkMsR0FBRyxLQUFLRDtZQUN4QyxNQUFNcEUsT0FBTyxJQUFJLENBQUNYLEVBQUUsQ0FBQ1ksT0FBTyxDQUFDOzs7O09BSTVCO1lBRUQsTUFBTWtDLFNBQVNuQyxLQUFLRSxHQUFHLENBQUNvRSxVQUFVM0QsV0FBVyxJQUFJOEIsU0FBUzBCO1lBQzFELE9BQU9oQyxPQUFPQyxPQUFPLEdBQUc7UUFDMUIsRUFBRSxPQUFPM0MsT0FBTztZQUNkLE1BQU0sSUFBSVIsV0FBQVMsWUFBWSxDQUFDLDBCQUEwQkQsTUFBSyxDQUFFLEVBQUVBO1FBQzVEO0lBQ0Y7O0FBbFhGaUYsNEJBQUEsR0FBQXhGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHBsdXM5OS9jcm9ueC11aS8uLi8uLi9zcmMvc3RvcmFnZS9zcWxpdGUudHM/M2M1NCJdLCJuYW1lcyI6WyJiZXR0ZXJfc3FsaXRlM18xIiwiX19pbXBvcnREZWZhdWx0IiwicmVxdWlyZSIsInR5cGVzX2pzXzEiLCJTUUxpdGVTdG9yYWdlQWRhcHRlciIsImNvbnN0cnVjdG9yIiwiZGJQYXRoIiwiZGIiLCJjb25uZWN0IiwiZGVmYXVsdCIsImluaXRUYWJsZXMiLCJlcnJvciIsIlN0b3JhZ2VFcnJvciIsImRpc2Nvbm5lY3QiLCJjbG9zZSIsImV4ZWMiLCJzYXZlSm9iIiwiam9iIiwic3RtdCIsInByZXBhcmUiLCJydW4iLCJuYW1lIiwic2NoZWR1bGUiLCJKU09OIiwic3RyaW5naWZ5Iiwib3B0aW9ucyIsImlzQWN0aXZlIiwiaXNQYXVzZWQiLCJjcmVhdGVkQXQiLCJ0b0lTT1N0cmluZyIsInVwZGF0ZWRBdCIsImxhc3RSdW4iLCJuZXh0UnVuIiwiZ2V0Sm9iIiwicm93IiwiZ2V0IiwiaGFuZGxlciIsIlByb21pc2UiLCJyZXNvbHZlIiwicGFyc2UiLCJpc19hY3RpdmUiLCJpc19wYXVzZWQiLCJEYXRlIiwiY3JlYXRlZF9hdCIsInVwZGF0ZWRfYXQiLCJsYXN0X3J1biIsInVuZGVmaW5lZCIsIm5leHRfcnVuIiwibGlzdEpvYnMiLCJyb3dzIiwiYWxsIiwibWFwIiwiZGVsZXRlSm9iIiwicmVzdWx0IiwiY2hhbmdlcyIsInBhdXNlSm9iIiwicmVzdW1lSm9iIiwic2F2ZUpvYlJ1biIsImlkIiwiam9iTmFtZSIsInN0YXR1cyIsInN0YXJ0VGltZSIsImVuZFRpbWUiLCJhdHRlbXB0IiwiZ2V0Sm9iUnVuIiwiam9iX25hbWUiLCJzdGFydF90aW1lIiwiZW5kX3RpbWUiLCJnZXRKb2JSdW5zIiwibGltaXQiLCJzcWwiLCJnZXRKb2JTdGF0cyIsInJ1bnNTdG10Iiwic3RhdHMiLCJqb2JTdG10Iiwiam9iSW5mbyIsInRvdGFsUnVucyIsInRvdGFsIiwic3VjY2Vzc2Z1bFJ1bnMiLCJzdWNjZXNzZnVsIiwiZmFpbGVkUnVucyIsImZhaWxlZCIsImF2ZXJhZ2VEdXJhdGlvbiIsImF2Z19kdXJhdGlvbiIsImFjcXVpcmVMb2NrIiwid29ya2VySWQiLCJ0dGwiLCJub3ciLCJleHBpcmVzQXQiLCJnZXRUaW1lIiwicmVsZWFzZUxvY2siLCJleHRlbmRMb2NrIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../core/dist/storage/sqlite.js\n");

/***/ }),

/***/ "(rsc)/../core/dist/types.js":
/*!*****************************!*\
  !*** ../core/dist/types.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.StorageError = exports.JobExecutionError = exports.CronxError = void 0;\nclass CronxError extends Error {\n    constructor(message, code, cause){\n        super(message);\n        this.code = code;\n        this.cause = cause;\n        this.name = \"CronxError\";\n    }\n}\nexports.CronxError = CronxError;\nclass JobExecutionError extends CronxError {\n    constructor(jobName, attempt, cause){\n        super(`Job '${jobName}' failed on attempt ${attempt}: ${cause.message}`, \"JOB_EXECUTION_ERROR\", cause);\n        this.name = \"JobExecutionError\";\n    }\n}\nexports.JobExecutionError = JobExecutionError;\nclass StorageError extends CronxError {\n    constructor(message, cause){\n        super(message, \"STORAGE_ERROR\", cause);\n        this.name = \"StorageError\";\n    }\n}\nexports.StorageError = StorageError; //# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vY29yZS9kaXN0L3R5cGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBcUZBLE1BQWFBLG1CQUFtQkM7SUFDOUJDLFlBQVlDLE9BQWUsRUFBU0MsSUFBYSxFQUFTQyxLQUFhO1FBQ3JFLEtBQUssQ0FBQ0Y7UUFENEIsS0FBQUMsSUFBSSxHQUFKQTtRQUFzQixLQUFBQyxLQUFLLEdBQUxBO1FBRXhELElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2Q7O0FBSkZDLGtCQUFBLEdBQUFQO0FBT0EsTUFBYVEsMEJBQTBCUjtJQUNyQ0UsWUFBWU8sT0FBZSxFQUFFQyxPQUFlLEVBQUVMLEtBQVk7UUFDeEQsS0FBSyxDQUFDLFFBQVFJLFFBQU8sc0JBQXVCQyxRQUFPLElBQUtMLE1BQU1GLE9BQU8sRUFBRSxFQUFFLHVCQUF1QkU7UUFDaEcsSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDZDs7QUFKRkMseUJBQUEsR0FBQUM7QUFPQSxNQUFhRyxxQkFBcUJYO0lBQ2hDRSxZQUFZQyxPQUFlLEVBQUVFLEtBQWE7UUFDeEMsS0FBSyxDQUFDRixTQUFTLGlCQUFpQkU7UUFDaEMsSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDZDs7QUFKRkMsb0JBQUEsR0FBQUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AcGx1czk5L2Nyb254LXVpLy4uL3NyYy90eXBlcy50cz82MjZlIl0sIm5hbWVzIjpbIkNyb254RXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsImNvZGUiLCJjYXVzZSIsIm5hbWUiLCJleHBvcnRzIiwiSm9iRXhlY3V0aW9uRXJyb3IiLCJqb2JOYW1lIiwiYXR0ZW1wdCIsIlN0b3JhZ2VFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../core/dist/types.js\n");

/***/ }),

/***/ "(rsc)/./src/app/api/jobs/route.ts":
/*!***********************************!*\
  !*** ./src/app/api/jobs/route.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GET: () => (/* binding */ GET),\n/* harmony export */   POST: () => (/* binding */ POST)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/../../node_modules/next/dist/api/server.js\");\n/* harmony import */ var _lib_cronx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/cronx */ \"(rsc)/./src/lib/cronx.ts\");\n\n\nasync function GET() {\n    try {\n        const cronx = (0,_lib_cronx__WEBPACK_IMPORTED_MODULE_1__.getCronxInstance)();\n        if (!cronx.isRunning) {\n            await cronx.start();\n        }\n        const jobs = await cronx.listJobs();\n        // Convert jobs to serializable DTOs, removing non-serializable fields like functions\n        const serializableJobs = jobs.map((job)=>({\n                name: job.name,\n                schedule: job.schedule,\n                paused: job.isPaused || false,\n                nextRun: job.nextRun ? job.nextRun.toISOString() : null,\n                lastRun: job.lastRun ? job.lastRun.toISOString() : null,\n                retries: job.options?.retries || 0,\n                timeout: job.options?.timeout || 5000,\n                backoff: job.options?.backoff || \"fixed\"\n            }));\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json(serializableJobs);\n    } catch (error) {\n        console.error(\"Error fetching jobs:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: \"Failed to fetch jobs\"\n        }, {\n            status: 500\n        });\n    }\n}\nasync function POST(request) {\n    try {\n        const body = await request.json();\n        const { name, schedule, code, options = {} } = body;\n        if (!name || !schedule || !code) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Missing required fields: name, schedule, code\"\n            }, {\n                status: 400\n            });\n        }\n        const cronx = (0,_lib_cronx__WEBPACK_IMPORTED_MODULE_1__.getCronxInstance)();\n        if (!cronx.isRunning) {\n            await cronx.start();\n        }\n        // Security: Only allow dynamic code execution in development\n        if (false) {}\n        // Create function from code string (DEVELOPMENT ONLY - not safe for production)\n        let jobFunction;\n        try {\n            jobFunction = new Function(\"return \" + code)();\n        } catch (error) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Invalid job function code\"\n            }, {\n                status: 400\n            });\n        }\n        await cronx.schedule(schedule, jobFunction, {\n            name,\n            ...options\n        });\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: true,\n            message: \"Job scheduled successfully\"\n        });\n    } catch (error) {\n        console.error(\"Error creating job:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: \"Failed to create job\"\n        }, {\n            status: 500\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvYXBwL2FwaS9qb2JzL3JvdXRlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBdUQ7QUFDVDtBQUV2QyxlQUFlRTtJQUNwQixJQUFJO1FBQ0YsTUFBTUMsUUFBUUYsNERBQWdCQTtRQUU5QixJQUFJLENBQUNFLE1BQU1DLFNBQVMsRUFBRTtZQUNwQixNQUFNRCxNQUFNRSxLQUFLO1FBQ25CO1FBRUEsTUFBTUMsT0FBTyxNQUFNSCxNQUFNSSxRQUFRO1FBRWpDLHFGQUFxRjtRQUNyRixNQUFNQyxtQkFBbUJGLEtBQUtHLEdBQUcsQ0FBQ0MsQ0FBQUEsTUFBUTtnQkFDeENDLE1BQU1ELElBQUlDLElBQUk7Z0JBQ2RDLFVBQVVGLElBQUlFLFFBQVE7Z0JBQ3RCQyxRQUFRSCxJQUFJSSxRQUFRLElBQUk7Z0JBQ3hCQyxTQUFTTCxJQUFJSyxPQUFPLEdBQUdMLElBQUlLLE9BQU8sQ0FBQ0MsV0FBVyxLQUFLO2dCQUNuREMsU0FBU1AsSUFBSU8sT0FBTyxHQUFHUCxJQUFJTyxPQUFPLENBQUNELFdBQVcsS0FBSztnQkFDbkRFLFNBQVNSLElBQUlTLE9BQU8sRUFBRUQsV0FBVztnQkFDakNFLFNBQVNWLElBQUlTLE9BQU8sRUFBRUMsV0FBVztnQkFDakNDLFNBQVNYLElBQUlTLE9BQU8sRUFBRUUsV0FBVztZQUNuQztRQUVBLE9BQU9yQixxREFBWUEsQ0FBQ3NCLElBQUksQ0FBQ2Q7SUFDM0IsRUFBRSxPQUFPZSxPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQyx3QkFBd0JBO1FBQ3RDLE9BQU92QixxREFBWUEsQ0FBQ3NCLElBQUksQ0FDdEI7WUFBRUMsT0FBTztRQUF1QixHQUNoQztZQUFFRSxRQUFRO1FBQUk7SUFFbEI7QUFDRjtBQUVPLGVBQWVDLEtBQUtDLE9BQW9CO0lBQzdDLElBQUk7UUFDRixNQUFNQyxPQUFPLE1BQU1ELFFBQVFMLElBQUk7UUFDL0IsTUFBTSxFQUFFWCxJQUFJLEVBQUVDLFFBQVEsRUFBRWlCLElBQUksRUFBRVYsVUFBVSxDQUFDLENBQUMsRUFBRSxHQUFHUztRQUUvQyxJQUFJLENBQUNqQixRQUFRLENBQUNDLFlBQVksQ0FBQ2lCLE1BQU07WUFDL0IsT0FBTzdCLHFEQUFZQSxDQUFDc0IsSUFBSSxDQUN0QjtnQkFBRUMsT0FBTztZQUFnRCxHQUN6RDtnQkFBRUUsUUFBUTtZQUFJO1FBRWxCO1FBRUEsTUFBTXRCLFFBQVFGLDREQUFnQkE7UUFFOUIsSUFBSSxDQUFDRSxNQUFNQyxTQUFTLEVBQUU7WUFDcEIsTUFBTUQsTUFBTUUsS0FBSztRQUNuQjtRQUVBLDZEQUE2RDtRQUM3RCxJQUFJeUIsS0FBeUIsRUFBYyxFQUsxQztRQUVELGdGQUFnRjtRQUNoRixJQUFJQztRQUNKLElBQUk7WUFDRkEsY0FBYyxJQUFJQyxTQUFTLFlBQVlIO1FBQ3pDLEVBQUUsT0FBT04sT0FBTztZQUNkLE9BQU92QixxREFBWUEsQ0FBQ3NCLElBQUksQ0FDdEI7Z0JBQUVDLE9BQU87WUFBNEIsR0FDckM7Z0JBQUVFLFFBQVE7WUFBSTtRQUVsQjtRQUVBLE1BQU10QixNQUFNUyxRQUFRLENBQUNBLFVBQVVtQixhQUFhO1lBQzFDcEI7WUFDQSxHQUFHUSxPQUFPO1FBQ1o7UUFFQSxPQUFPbkIscURBQVlBLENBQUNzQixJQUFJLENBQUM7WUFBRVcsU0FBUztZQUFNQyxTQUFTO1FBQTZCO0lBQ2xGLEVBQUUsT0FBT1gsT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMsdUJBQXVCQTtRQUNyQyxPQUFPdkIscURBQVlBLENBQUNzQixJQUFJLENBQ3RCO1lBQUVDLE9BQU87UUFBdUIsR0FDaEM7WUFBRUUsUUFBUTtRQUFJO0lBRWxCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AcGx1czk5L2Nyb254LXVpLy4vc3JjL2FwcC9hcGkvam9icy9yb3V0ZS50cz85ODVhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5leHRSZXF1ZXN0LCBOZXh0UmVzcG9uc2UgfSBmcm9tICduZXh0L3NlcnZlcidcbmltcG9ydCB7IGdldENyb254SW5zdGFuY2UgfSBmcm9tICdAL2xpYi9jcm9ueCdcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIEdFVCgpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBjcm9ueCA9IGdldENyb254SW5zdGFuY2UoKVxuICAgIFxuICAgIGlmICghY3JvbnguaXNSdW5uaW5nKSB7XG4gICAgICBhd2FpdCBjcm9ueC5zdGFydCgpXG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGpvYnMgPSBhd2FpdCBjcm9ueC5saXN0Sm9icygpXG4gICAgXG4gICAgLy8gQ29udmVydCBqb2JzIHRvIHNlcmlhbGl6YWJsZSBEVE9zLCByZW1vdmluZyBub24tc2VyaWFsaXphYmxlIGZpZWxkcyBsaWtlIGZ1bmN0aW9uc1xuICAgIGNvbnN0IHNlcmlhbGl6YWJsZUpvYnMgPSBqb2JzLm1hcChqb2IgPT4gKHtcbiAgICAgIG5hbWU6IGpvYi5uYW1lLFxuICAgICAgc2NoZWR1bGU6IGpvYi5zY2hlZHVsZSxcbiAgICAgIHBhdXNlZDogam9iLmlzUGF1c2VkIHx8IGZhbHNlLFxuICAgICAgbmV4dFJ1bjogam9iLm5leHRSdW4gPyBqb2IubmV4dFJ1bi50b0lTT1N0cmluZygpIDogbnVsbCxcbiAgICAgIGxhc3RSdW46IGpvYi5sYXN0UnVuID8gam9iLmxhc3RSdW4udG9JU09TdHJpbmcoKSA6IG51bGwsXG4gICAgICByZXRyaWVzOiBqb2Iub3B0aW9ucz8ucmV0cmllcyB8fCAwLFxuICAgICAgdGltZW91dDogam9iLm9wdGlvbnM/LnRpbWVvdXQgfHwgNTAwMCxcbiAgICAgIGJhY2tvZmY6IGpvYi5vcHRpb25zPy5iYWNrb2ZmIHx8ICdmaXhlZCdcbiAgICB9KSlcbiAgICBcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oc2VyaWFsaXphYmxlSm9icylcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBqb2JzOicsIGVycm9yKVxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgIHsgZXJyb3I6ICdGYWlsZWQgdG8gZmV0Y2ggam9icycgfSxcbiAgICAgIHsgc3RhdHVzOiA1MDAgfVxuICAgIClcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gUE9TVChyZXF1ZXN0OiBOZXh0UmVxdWVzdCkge1xuICB0cnkge1xuICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXF1ZXN0Lmpzb24oKVxuICAgIGNvbnN0IHsgbmFtZSwgc2NoZWR1bGUsIGNvZGUsIG9wdGlvbnMgPSB7fSB9ID0gYm9keVxuICAgIFxuICAgIGlmICghbmFtZSB8fCAhc2NoZWR1bGUgfHwgIWNvZGUpIHtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ01pc3NpbmcgcmVxdWlyZWQgZmllbGRzOiBuYW1lLCBzY2hlZHVsZSwgY29kZScgfSxcbiAgICAgICAgeyBzdGF0dXM6IDQwMCB9XG4gICAgICApXG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGNyb254ID0gZ2V0Q3JvbnhJbnN0YW5jZSgpXG4gICAgXG4gICAgaWYgKCFjcm9ueC5pc1J1bm5pbmcpIHtcbiAgICAgIGF3YWl0IGNyb254LnN0YXJ0KClcbiAgICB9XG4gICAgXG4gICAgLy8gU2VjdXJpdHk6IE9ubHkgYWxsb3cgZHluYW1pYyBjb2RlIGV4ZWN1dGlvbiBpbiBkZXZlbG9wbWVudFxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHsgZXJyb3I6ICdEeW5hbWljIGpvYiBjcmVhdGlvbiBpcyBkaXNhYmxlZCBpbiBwcm9kdWN0aW9uIGZvciBzZWN1cml0eScgfSxcbiAgICAgICAgeyBzdGF0dXM6IDQwMyB9XG4gICAgICApXG4gICAgfVxuICAgIFxuICAgIC8vIENyZWF0ZSBmdW5jdGlvbiBmcm9tIGNvZGUgc3RyaW5nIChERVZFTE9QTUVOVCBPTkxZIC0gbm90IHNhZmUgZm9yIHByb2R1Y3Rpb24pXG4gICAgbGV0IGpvYkZ1bmN0aW9uXG4gICAgdHJ5IHtcbiAgICAgIGpvYkZ1bmN0aW9uID0gbmV3IEZ1bmN0aW9uKCdyZXR1cm4gJyArIGNvZGUpKClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7IGVycm9yOiAnSW52YWxpZCBqb2IgZnVuY3Rpb24gY29kZScgfSxcbiAgICAgICAgeyBzdGF0dXM6IDQwMCB9XG4gICAgICApXG4gICAgfVxuICAgIFxuICAgIGF3YWl0IGNyb254LnNjaGVkdWxlKHNjaGVkdWxlLCBqb2JGdW5jdGlvbiwge1xuICAgICAgbmFtZSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9KVxuICAgIFxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IHN1Y2Nlc3M6IHRydWUsIG1lc3NhZ2U6ICdKb2Igc2NoZWR1bGVkIHN1Y2Nlc3NmdWxseScgfSlcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBqb2I6JywgZXJyb3IpXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgeyBlcnJvcjogJ0ZhaWxlZCB0byBjcmVhdGUgam9iJyB9LFxuICAgICAgeyBzdGF0dXM6IDUwMCB9XG4gICAgKVxuICB9XG59Il0sIm5hbWVzIjpbIk5leHRSZXNwb25zZSIsImdldENyb254SW5zdGFuY2UiLCJHRVQiLCJjcm9ueCIsImlzUnVubmluZyIsInN0YXJ0Iiwiam9icyIsImxpc3RKb2JzIiwic2VyaWFsaXphYmxlSm9icyIsIm1hcCIsImpvYiIsIm5hbWUiLCJzY2hlZHVsZSIsInBhdXNlZCIsImlzUGF1c2VkIiwibmV4dFJ1biIsInRvSVNPU3RyaW5nIiwibGFzdFJ1biIsInJldHJpZXMiLCJvcHRpb25zIiwidGltZW91dCIsImJhY2tvZmYiLCJqc29uIiwiZXJyb3IiLCJjb25zb2xlIiwic3RhdHVzIiwiUE9TVCIsInJlcXVlc3QiLCJib2R5IiwiY29kZSIsInByb2Nlc3MiLCJqb2JGdW5jdGlvbiIsIkZ1bmN0aW9uIiwic3VjY2VzcyIsIm1lc3NhZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/app/api/jobs/route.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/cronx.ts":
/*!**************************!*\
  !*** ./src/lib/cronx.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ensureCronxStarted: () => (/* binding */ ensureCronxStarted),\n/* harmony export */   getCronxInstance: () => (/* binding */ getCronxInstance)\n/* harmony export */ });\n/* harmony import */ var _plus99_cronx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @plus99/cronx */ \"(rsc)/../core/dist/index.js\");\n\nfunction getCronxInstance() {\n    if (!global.__cronxInstance) {\n        // Initialize with memory storage for development, can be configured via env\n        const storageUrl = process.env.CRONX_STORAGE_URL || \"memory://\";\n        global.__cronxInstance = new _plus99_cronx__WEBPACK_IMPORTED_MODULE_0__.Cronx({\n            storage: storageUrl,\n            workerId: \"cronx-ui\",\n            metrics: true\n        });\n    }\n    return global.__cronxInstance;\n}\nasync function ensureCronxStarted() {\n    const cronx = getCronxInstance();\n    if (!cronx.isRunning) {\n        await cronx.start();\n    }\n    return cronx;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvbGliL2Nyb254LnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFxQztBQU85QixTQUFTQztJQUNkLElBQUksQ0FBQ0MsT0FBT0MsZUFBZSxFQUFFO1FBQzNCLDRFQUE0RTtRQUM1RSxNQUFNQyxhQUFhQyxRQUFRQyxHQUFHLENBQUNDLGlCQUFpQixJQUFJO1FBRXBETCxPQUFPQyxlQUFlLEdBQUcsSUFBSUgsZ0RBQUtBLENBQUM7WUFDakNRLFNBQVNKO1lBQ1RLLFVBQVU7WUFDVkMsU0FBUztRQUNYO0lBQ0Y7SUFFQSxPQUFPUixPQUFPQyxlQUFlO0FBQy9CO0FBRU8sZUFBZVE7SUFDcEIsTUFBTUMsUUFBUVg7SUFFZCxJQUFJLENBQUNXLE1BQU1DLFNBQVMsRUFBRTtRQUNwQixNQUFNRCxNQUFNRSxLQUFLO0lBQ25CO0lBRUEsT0FBT0Y7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL0BwbHVzOTkvY3JvbngtdWkvLi9zcmMvbGliL2Nyb254LnRzP2I2ZTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ3JvbnggfSBmcm9tICdAcGx1czk5L2Nyb254J1xuXG4vLyBTaW5nbGV0b24gaW5zdGFuY2UgZm9yIHRoZSBVSSAtIHVzaW5nIGdsb2JhbFRoaXMgdG8gc3Vydml2ZSBITVIgaW4gZGV2ZWxvcG1lbnRcbmRlY2xhcmUgZ2xvYmFsIHtcbiAgdmFyIF9fY3JvbnhJbnN0YW5jZTogQ3JvbnggfCB1bmRlZmluZWRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENyb254SW5zdGFuY2UoKTogQ3Jvbngge1xuICBpZiAoIWdsb2JhbC5fX2Nyb254SW5zdGFuY2UpIHtcbiAgICAvLyBJbml0aWFsaXplIHdpdGggbWVtb3J5IHN0b3JhZ2UgZm9yIGRldmVsb3BtZW50LCBjYW4gYmUgY29uZmlndXJlZCB2aWEgZW52XG4gICAgY29uc3Qgc3RvcmFnZVVybCA9IHByb2Nlc3MuZW52LkNST05YX1NUT1JBR0VfVVJMIHx8ICdtZW1vcnk6Ly8nXG4gICAgXG4gICAgZ2xvYmFsLl9fY3JvbnhJbnN0YW5jZSA9IG5ldyBDcm9ueCh7XG4gICAgICBzdG9yYWdlOiBzdG9yYWdlVXJsLFxuICAgICAgd29ya2VySWQ6ICdjcm9ueC11aScsXG4gICAgICBtZXRyaWNzOiB0cnVlXG4gICAgfSlcbiAgfVxuICBcbiAgcmV0dXJuIGdsb2JhbC5fX2Nyb254SW5zdGFuY2Vcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVuc3VyZUNyb254U3RhcnRlZCgpOiBQcm9taXNlPENyb254PiB7XG4gIGNvbnN0IGNyb254ID0gZ2V0Q3JvbnhJbnN0YW5jZSgpXG4gIFxuICBpZiAoIWNyb254LmlzUnVubmluZykge1xuICAgIGF3YWl0IGNyb254LnN0YXJ0KClcbiAgfVxuICBcbiAgcmV0dXJuIGNyb254XG59Il0sIm5hbWVzIjpbIkNyb254IiwiZ2V0Q3JvbnhJbnN0YW5jZSIsImdsb2JhbCIsIl9fY3JvbnhJbnN0YW5jZSIsInN0b3JhZ2VVcmwiLCJwcm9jZXNzIiwiZW52IiwiQ1JPTlhfU1RPUkFHRV9VUkwiLCJzdG9yYWdlIiwid29ya2VySWQiLCJtZXRyaWNzIiwiZW5zdXJlQ3JvbnhTdGFydGVkIiwiY3JvbngiLCJpc1J1bm5pbmciLCJzdGFydCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/cronx.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/@opentelemetry","vendor-chunks/@redis","vendor-chunks/luxon","vendor-chunks/prom-client","vendor-chunks/generic-pool","vendor-chunks/cron-parser","vendor-chunks/tdigest","vendor-chunks/bintrees","vendor-chunks/yallist","vendor-chunks/cluster-key-slot","vendor-chunks/redis"], () => (__webpack_exec__("(rsc)/../../node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fjobs%2Froute&page=%2Fapi%2Fjobs%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fjobs%2Froute.ts&appDir=%2Fhome%2Frunner%2Fworkspace%2Fpackages%2Fui%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2Fhome%2Frunner%2Fworkspace%2Fpackages%2Fui&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();