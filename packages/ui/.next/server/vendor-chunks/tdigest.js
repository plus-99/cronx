/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/tdigest";
exports.ids = ["vendor-chunks/tdigest"];
exports.modules = {

/***/ "(rsc)/../../node_modules/tdigest/tdigest.js":
/*!*********************************************!*\
  !*** ../../node_modules/tdigest/tdigest.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("//\n// TDigest:\n//\n// approximate distribution percentiles from a stream of reals\n//\nvar RBTree = (__webpack_require__(/*! bintrees */ \"(rsc)/../../node_modules/bintrees/index.js\").RBTree);\n\nfunction TDigest(delta, K, CX) {\n    // allocate a TDigest structure.\n    //\n    // delta is the compression factor, the max fraction of mass that\n    // can be owned by one centroid (bigger, up to 1.0, means more\n    // compression). delta=false switches off TDigest behavior and treats\n    // the distribution as discrete, with no merging and exact values\n    // reported.\n    //\n    // K is a size threshold that triggers recompression as the TDigest\n    // grows during input.  (Set it to 0 to disable automatic recompression)\n    //\n    // CX specifies how often to update cached cumulative totals used\n    // for quantile estimation during ingest (see cumulate()).  Set to\n    // 0 to use exact quantiles for each new point.\n    //\n    this.discrete = (delta === false);\n    this.delta = delta || 0.01;\n    this.K = (K === undefined) ? 25 : K;\n    this.CX = (CX === undefined) ? 1.1 : CX;\n    this.centroids = new RBTree(compare_centroid_means);\n    this.nreset = 0;\n    this.reset();\n}\n\nTDigest.prototype.reset = function() {\n    // prepare to digest new points.\n    //\n    this.centroids.clear();\n    this.n = 0;\n    this.nreset += 1;\n    this.last_cumulate = 0;\n};\n\nTDigest.prototype.size = function() {\n    return this.centroids.size;\n};\n\nTDigest.prototype.toArray = function(everything) {\n    // return {mean,n} of centroids as an array ordered by mean.\n    //\n    var result = [];\n    if (everything) {\n        this._cumulate(true); // be sure cumns are exact\n        this.centroids.each(function(c) { result.push(c); });\n    } else {\n        this.centroids.each(function(c) { result.push({mean:c.mean, n:c.n}); });\n    }\n    return result;\n};\n\nTDigest.prototype.summary = function() {\n    var approx = (this.discrete) ? \"exact \" : \"approximating \";\n    var s = [approx + this.n + \" samples using \" + this.size() + \" centroids\",\n             \"min = \"+this.percentile(0),\n             \"Q1  = \"+this.percentile(0.25),\n             \"Q2  = \"+this.percentile(0.5),\n             \"Q3  = \"+this.percentile(0.75),\n             \"max = \"+this.percentile(1.0)];\n    return s.join('\\n');\n};\n\nfunction compare_centroid_means(a, b) {\n    // order two centroids by mean.\n    //\n    return (a.mean > b.mean) ? 1 : (a.mean < b.mean) ? -1 : 0;\n}\n\nfunction compare_centroid_mean_cumns(a, b) {\n    // order two centroids by mean_cumn.\n    //\n    return (a.mean_cumn - b.mean_cumn);\n}\n\nTDigest.prototype.push = function(x, n) {\n    // incorporate value or array of values x, having count n into the\n    // TDigest. n defaults to 1.\n    //\n    n = n || 1;\n    x = Array.isArray(x) ? x : [x];\n    for (var i = 0 ; i < x.length ; i++) {\n        this._digest(x[i], n);\n    }\n};\n\nTDigest.prototype.push_centroid = function(c) {\n    // incorporate centroid or array of centroids c\n    //\n    c = Array.isArray(c) ? c : [c];\n    for (var i = 0 ; i < c.length ; i++) {\n        this._digest(c[i].mean, c[i].n);\n    }\n};\n\nTDigest.prototype._cumulate = function(exact) {\n    // update cumulative counts for each centroid\n    //\n    // exact: falsey means only cumulate after sufficient\n    // growth. During ingest, these counts are used as quantile\n    // estimates, and they work well even when somewhat out of\n    // date. (this is a departure from the publication, you may set CX\n    // to 0 to disable).\n    //\n    if (this.n === this.last_cumulate ||\n        !exact && this.CX && this.CX > (this.n / this.last_cumulate)) {\n        return;\n    }\n    var cumn = 0;\n    this.centroids.each(function(c) {\n        c.mean_cumn = cumn + c.n / 2; // half of n at the mean\n        cumn = c.cumn = cumn + c.n;\n    });\n    this.n = this.last_cumulate = cumn;\n};\n\nTDigest.prototype.find_nearest = function(x) {\n    // find the centroid closest to x. The assumption of\n    // unique means and a unique nearest centroid departs from the\n    // paper, see _digest() below\n    //\n    if (this.size() === 0) {\n        return null;\n    }\n    var iter = this.centroids.lowerBound({mean:x}); // x <= iter || iter==null\n    var c = (iter.data() === null) ? iter.prev() : iter.data();\n    if (c.mean === x || this.discrete) {\n        return c; // c is either x or a neighbor (discrete: no distance func)\n    }\n    var prev = iter.prev();\n    if (prev && Math.abs(prev.mean - x) < Math.abs(c.mean - x)) {\n        return prev;\n    } else {\n        return c;\n    }\n};\n\nTDigest.prototype._new_centroid = function(x, n, cumn) {\n    // create and insert a new centroid into the digest (don't update\n    // cumulatives).\n    //\n    var c = {mean:x, n:n, cumn:cumn};\n    this.centroids.insert(c);\n    this.n += n;\n    return c;\n};\n\nTDigest.prototype._addweight = function(nearest, x, n) {\n    // add weight at location x to nearest centroid.  adding x to\n    // nearest will not shift its relative position in the tree and\n    // require reinsertion.\n    //\n    if (x !== nearest.mean) {\n        nearest.mean += n * (x - nearest.mean) / (nearest.n + n);\n    }\n    nearest.cumn += n;\n    nearest.mean_cumn += n / 2;\n    nearest.n += n;\n    this.n += n;\n};\n\nTDigest.prototype._digest = function(x, n) {\n    // incorporate value x, having count n into the TDigest.\n    //\n    var min = this.centroids.min();\n    var max = this.centroids.max();\n    var nearest = this.find_nearest(x);\n    if (nearest && nearest.mean === x) {\n        // accumulate exact matches into the centroid without\n        // limit. this is a departure from the paper, made so\n        // centroids remain unique and code can be simple.\n        this._addweight(nearest, x, n);\n    } else if (nearest === min) {\n        this._new_centroid(x, n, 0); // new point around min boundary\n    } else if (nearest === max ) {\n        this._new_centroid(x, n, this.n); // new point around max boundary\n    } else if (this.discrete) {\n        this._new_centroid(x, n, nearest.cumn); // never merge\n    } else {\n        // conider a merge based on nearest centroid's capacity. if\n        // there's not room for all of n, don't bother merging any of\n        // it into nearest, as we'll have to make a new centroid\n        // anyway for the remainder (departure from the paper).\n        var p = nearest.mean_cumn / this.n;\n        var max_n = Math.floor(4 * this.n * this.delta * p * (1 - p));\n        if (max_n - nearest.n >= n) {\n            this._addweight(nearest, x, n);\n        } else {\n            this._new_centroid(x, n, nearest.cumn);\n        }\n    }\n    this._cumulate(false);\n    if (!this.discrete && this.K && this.size() > this.K / this.delta) {\n        // re-process the centroids and hope for some compression.\n        this.compress();\n    }\n};\n\nTDigest.prototype.bound_mean = function(x) {\n    // find centroids lower and upper such that lower.mean < x <\n    // upper.mean or lower.mean === x === upper.mean. Don't call\n    // this for x out of bounds.\n    //\n    var iter = this.centroids.upperBound({mean:x}); // x < iter\n    var lower = iter.prev();      // lower <= x\n    var upper = (lower.mean === x) ? lower : iter.next();\n    return [lower, upper];\n};\n\nTDigest.prototype.p_rank = function(x_or_xlist) {\n    // return approximate percentile-ranks (0..1) for data value x.\n    // or list of x.  calculated according to\n    // https://en.wikipedia.org/wiki/Percentile_rank\n    //\n    // (Note that in continuous mode, boundary sample values will\n    // report half their centroid weight inward from 0/1 as the\n    // percentile-rank. X values outside the observed range return\n    // 0/1)\n    //\n    // this triggers cumulate() if cumn's are out of date.\n    //\n    var xs = Array.isArray(x_or_xlist) ? x_or_xlist : [x_or_xlist];\n    var ps = xs.map(this._p_rank, this);\n    return Array.isArray(x_or_xlist) ? ps : ps[0];\n};\n\nTDigest.prototype._p_rank = function(x) {\n    if (this.size() === 0) {\n        return undefined;\n    } else if (x < this.centroids.min().mean) {\n        return 0.0;\n    } else if (x > this.centroids.max().mean) {\n        return 1.0;\n    }\n    // find centroids that bracket x and interpolate x's cumn from\n    // their cumn's.\n    this._cumulate(true); // be sure cumns are exact\n    var bound = this.bound_mean(x);\n    var lower = bound[0], upper = bound[1];\n    if (this.discrete) {\n        return lower.cumn / this.n;\n    } else {\n        var cumn = lower.mean_cumn;\n        if (lower !== upper) {\n            cumn += (x - lower.mean) * (upper.mean_cumn - lower.mean_cumn) / (upper.mean - lower.mean);\n        }\n        return cumn / this.n;\n    }\n};\n\nTDigest.prototype.bound_mean_cumn = function(cumn) {\n    // find centroids lower and upper such that lower.mean_cumn < x <\n    // upper.mean_cumn or lower.mean_cumn === x === upper.mean_cumn. Don't call\n    // this for cumn out of bounds.\n    //\n    // XXX because mean and mean_cumn give rise to the same sort order\n    // (up to identical means), use the mean rbtree for our search.\n    this.centroids._comparator = compare_centroid_mean_cumns;\n    var iter = this.centroids.upperBound({mean_cumn:cumn}); // cumn < iter\n    this.centroids._comparator = compare_centroid_means;\n    var lower = iter.prev();      // lower <= cumn\n    var upper = (lower && lower.mean_cumn === cumn) ? lower : iter.next();\n    return [lower, upper];\n};\n\nTDigest.prototype.percentile = function(p_or_plist) {\n    // for percentage p (0..1), or for each p in a list of ps, return\n    // the smallest data value q at which at least p percent of the\n    // observations <= q.\n    //\n    // for discrete distributions, this selects q using the Nearest\n    // Rank Method\n    // (https://en.wikipedia.org/wiki/Percentile#The_Nearest_Rank_method)\n    // (in scipy, same as percentile(...., interpolation='higher')\n    //\n    // for continuous distributions, interpolates data values between\n    // count-weighted bracketing means.\n    //\n    // this triggers cumulate() if cumn's are out of date.\n    //\n    var ps = Array.isArray(p_or_plist) ? p_or_plist : [p_or_plist];\n    var qs = ps.map(this._percentile, this);\n    return Array.isArray(p_or_plist) ? qs : qs[0];\n};\n\nTDigest.prototype._percentile = function(p) {\n    if (this.size() === 0) {\n        return undefined;\n    }\n    this._cumulate(true); // be sure cumns are exact\n    var h = this.n * p;\n    var bound = this.bound_mean_cumn(h);\n    var lower = bound[0], upper = bound[1];\n\n    if (upper === lower || lower === null || upper === null) {\n        return (lower || upper).mean;\n    } else if (!this.discrete) {\n        return lower.mean + (h - lower.mean_cumn) * (upper.mean - lower.mean) / (upper.mean_cumn - lower.mean_cumn);\n    } else if (h <= lower.cumn) {\n        return lower.mean;\n    } else {\n        return upper.mean;\n    }\n};\n\nfunction pop_random(choices) {\n    // remove and return an item randomly chosen from the array of choices\n    // (mutates choices)\n    //\n    var idx = Math.floor(Math.random() * choices.length);\n    return choices.splice(idx, 1)[0];\n}\n\nTDigest.prototype.compress = function() {\n    // TDigests experience worst case compression (none) when input\n    // increases monotonically.  Improve on any bad luck by\n    // reconsuming digest centroids as if they were weighted points\n    // while shuffling their order (and hope for the best).\n    //\n    if (this.compressing) {\n        return;\n    }\n    var points = this.toArray();\n    this.reset();\n    this.compressing = true;\n    while (points.length > 0) {\n        this.push_centroid(pop_random(points));\n    }\n    this._cumulate(true);\n    this.compressing = false;\n};\n\nfunction Digest(config) {\n    // allocate a distribution digest structure. This is an extension\n    // of a TDigest structure that starts in exact histogram (discrete)\n    // mode, and automatically switches to TDigest mode for large\n    // samples that appear to be from a continuous distribution.\n    //\n    this.config = config || {};\n    this.mode = this.config.mode || 'auto'; // disc, cont, auto\n    TDigest.call(this, this.mode === 'cont' ? config.delta : false);\n    this.digest_ratio = this.config.ratio || 0.9;\n    this.digest_thresh = this.config.thresh || 1000;\n    this.n_unique = 0;\n}\nDigest.prototype = Object.create(TDigest.prototype);\nDigest.prototype.constructor = Digest;\n\nDigest.prototype.push = function(x_or_xlist) {\n    TDigest.prototype.push.call(this, x_or_xlist);\n    this.check_continuous();\n};\n\nDigest.prototype._new_centroid = function(x, n, cumn) {\n    this.n_unique += 1;\n    TDigest.prototype._new_centroid.call(this, x, n, cumn);\n};\n\nDigest.prototype._addweight = function(nearest, x, n) {\n    if (nearest.n === 1) {\n        this.n_unique -= 1;\n    }\n    TDigest.prototype._addweight.call(this, nearest, x, n);\n};\n\nDigest.prototype.check_continuous = function() {\n    // while in 'auto' mode, if there are many unique elements, assume\n    // they are from a continuous distribution and switch to 'cont'\n    // mode (tdigest behavior). Return true on transition from\n    // disctete to continuous.\n    if (this.mode !== 'auto' || this.size() < this.digest_thresh) {\n        return false;\n    }\n    if (this.n_unique / this.size() > this.digest_ratio) {\n        this.mode = 'cont';\n        this.discrete = false;\n        this.delta = this.config.delta || 0.01;\n        this.compress();\n        return true;\n    }\n    return false;\n};\n\nmodule.exports = {\n    'TDigest': TDigest,\n    'Digest': Digest\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3RkaWdlc3QvdGRpZ2VzdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwwRkFBMEI7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsMENBQTBDLGlCQUFpQjtBQUMzRCxNQUFNO0FBQ04sMENBQTBDLGFBQWEsbUJBQW1CLElBQUk7QUFDOUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPLEdBQUc7QUFDcEQ7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixxQ0FBcUM7QUFDckMsTUFBTTtBQUNOLDBDQUEwQztBQUMxQyxNQUFNO0FBQ04sZ0RBQWdEO0FBQ2hELE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU8sR0FBRztBQUNwRCxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGVBQWUsR0FBRztBQUM1RDtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BwbHVzOTkvY3JvbngtdWkvLi4vLi4vbm9kZV9tb2R1bGVzL3RkaWdlc3QvdGRpZ2VzdC5qcz9lNDBhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vXG4vLyBURGlnZXN0OlxuLy9cbi8vIGFwcHJveGltYXRlIGRpc3RyaWJ1dGlvbiBwZXJjZW50aWxlcyBmcm9tIGEgc3RyZWFtIG9mIHJlYWxzXG4vL1xudmFyIFJCVHJlZSA9IHJlcXVpcmUoJ2JpbnRyZWVzJykuUkJUcmVlO1xuXG5mdW5jdGlvbiBURGlnZXN0KGRlbHRhLCBLLCBDWCkge1xuICAgIC8vIGFsbG9jYXRlIGEgVERpZ2VzdCBzdHJ1Y3R1cmUuXG4gICAgLy9cbiAgICAvLyBkZWx0YSBpcyB0aGUgY29tcHJlc3Npb24gZmFjdG9yLCB0aGUgbWF4IGZyYWN0aW9uIG9mIG1hc3MgdGhhdFxuICAgIC8vIGNhbiBiZSBvd25lZCBieSBvbmUgY2VudHJvaWQgKGJpZ2dlciwgdXAgdG8gMS4wLCBtZWFucyBtb3JlXG4gICAgLy8gY29tcHJlc3Npb24pLiBkZWx0YT1mYWxzZSBzd2l0Y2hlcyBvZmYgVERpZ2VzdCBiZWhhdmlvciBhbmQgdHJlYXRzXG4gICAgLy8gdGhlIGRpc3RyaWJ1dGlvbiBhcyBkaXNjcmV0ZSwgd2l0aCBubyBtZXJnaW5nIGFuZCBleGFjdCB2YWx1ZXNcbiAgICAvLyByZXBvcnRlZC5cbiAgICAvL1xuICAgIC8vIEsgaXMgYSBzaXplIHRocmVzaG9sZCB0aGF0IHRyaWdnZXJzIHJlY29tcHJlc3Npb24gYXMgdGhlIFREaWdlc3RcbiAgICAvLyBncm93cyBkdXJpbmcgaW5wdXQuICAoU2V0IGl0IHRvIDAgdG8gZGlzYWJsZSBhdXRvbWF0aWMgcmVjb21wcmVzc2lvbilcbiAgICAvL1xuICAgIC8vIENYIHNwZWNpZmllcyBob3cgb2Z0ZW4gdG8gdXBkYXRlIGNhY2hlZCBjdW11bGF0aXZlIHRvdGFscyB1c2VkXG4gICAgLy8gZm9yIHF1YW50aWxlIGVzdGltYXRpb24gZHVyaW5nIGluZ2VzdCAoc2VlIGN1bXVsYXRlKCkpLiAgU2V0IHRvXG4gICAgLy8gMCB0byB1c2UgZXhhY3QgcXVhbnRpbGVzIGZvciBlYWNoIG5ldyBwb2ludC5cbiAgICAvL1xuICAgIHRoaXMuZGlzY3JldGUgPSAoZGVsdGEgPT09IGZhbHNlKTtcbiAgICB0aGlzLmRlbHRhID0gZGVsdGEgfHwgMC4wMTtcbiAgICB0aGlzLksgPSAoSyA9PT0gdW5kZWZpbmVkKSA/IDI1IDogSztcbiAgICB0aGlzLkNYID0gKENYID09PSB1bmRlZmluZWQpID8gMS4xIDogQ1g7XG4gICAgdGhpcy5jZW50cm9pZHMgPSBuZXcgUkJUcmVlKGNvbXBhcmVfY2VudHJvaWRfbWVhbnMpO1xuICAgIHRoaXMubnJlc2V0ID0gMDtcbiAgICB0aGlzLnJlc2V0KCk7XG59XG5cblREaWdlc3QucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gcHJlcGFyZSB0byBkaWdlc3QgbmV3IHBvaW50cy5cbiAgICAvL1xuICAgIHRoaXMuY2VudHJvaWRzLmNsZWFyKCk7XG4gICAgdGhpcy5uID0gMDtcbiAgICB0aGlzLm5yZXNldCArPSAxO1xuICAgIHRoaXMubGFzdF9jdW11bGF0ZSA9IDA7XG59O1xuXG5URGlnZXN0LnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY2VudHJvaWRzLnNpemU7XG59O1xuXG5URGlnZXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24oZXZlcnl0aGluZykge1xuICAgIC8vIHJldHVybiB7bWVhbixufSBvZiBjZW50cm9pZHMgYXMgYW4gYXJyYXkgb3JkZXJlZCBieSBtZWFuLlxuICAgIC8vXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGlmIChldmVyeXRoaW5nKSB7XG4gICAgICAgIHRoaXMuX2N1bXVsYXRlKHRydWUpOyAvLyBiZSBzdXJlIGN1bW5zIGFyZSBleGFjdFxuICAgICAgICB0aGlzLmNlbnRyb2lkcy5lYWNoKGZ1bmN0aW9uKGMpIHsgcmVzdWx0LnB1c2goYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2VudHJvaWRzLmVhY2goZnVuY3Rpb24oYykgeyByZXN1bHQucHVzaCh7bWVhbjpjLm1lYW4sIG46Yy5ufSk7IH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuVERpZ2VzdC5wcm90b3R5cGUuc3VtbWFyeSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcHByb3ggPSAodGhpcy5kaXNjcmV0ZSkgPyBcImV4YWN0IFwiIDogXCJhcHByb3hpbWF0aW5nIFwiO1xuICAgIHZhciBzID0gW2FwcHJveCArIHRoaXMubiArIFwiIHNhbXBsZXMgdXNpbmcgXCIgKyB0aGlzLnNpemUoKSArIFwiIGNlbnRyb2lkc1wiLFxuICAgICAgICAgICAgIFwibWluID0gXCIrdGhpcy5wZXJjZW50aWxlKDApLFxuICAgICAgICAgICAgIFwiUTEgID0gXCIrdGhpcy5wZXJjZW50aWxlKDAuMjUpLFxuICAgICAgICAgICAgIFwiUTIgID0gXCIrdGhpcy5wZXJjZW50aWxlKDAuNSksXG4gICAgICAgICAgICAgXCJRMyAgPSBcIit0aGlzLnBlcmNlbnRpbGUoMC43NSksXG4gICAgICAgICAgICAgXCJtYXggPSBcIit0aGlzLnBlcmNlbnRpbGUoMS4wKV07XG4gICAgcmV0dXJuIHMuam9pbignXFxuJyk7XG59O1xuXG5mdW5jdGlvbiBjb21wYXJlX2NlbnRyb2lkX21lYW5zKGEsIGIpIHtcbiAgICAvLyBvcmRlciB0d28gY2VudHJvaWRzIGJ5IG1lYW4uXG4gICAgLy9cbiAgICByZXR1cm4gKGEubWVhbiA+IGIubWVhbikgPyAxIDogKGEubWVhbiA8IGIubWVhbikgPyAtMSA6IDA7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVfY2VudHJvaWRfbWVhbl9jdW1ucyhhLCBiKSB7XG4gICAgLy8gb3JkZXIgdHdvIGNlbnRyb2lkcyBieSBtZWFuX2N1bW4uXG4gICAgLy9cbiAgICByZXR1cm4gKGEubWVhbl9jdW1uIC0gYi5tZWFuX2N1bW4pO1xufVxuXG5URGlnZXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oeCwgbikge1xuICAgIC8vIGluY29ycG9yYXRlIHZhbHVlIG9yIGFycmF5IG9mIHZhbHVlcyB4LCBoYXZpbmcgY291bnQgbiBpbnRvIHRoZVxuICAgIC8vIFREaWdlc3QuIG4gZGVmYXVsdHMgdG8gMS5cbiAgICAvL1xuICAgIG4gPSBuIHx8IDE7XG4gICAgeCA9IEFycmF5LmlzQXJyYXkoeCkgPyB4IDogW3hdO1xuICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IHgubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX2RpZ2VzdCh4W2ldLCBuKTtcbiAgICB9XG59O1xuXG5URGlnZXN0LnByb3RvdHlwZS5wdXNoX2NlbnRyb2lkID0gZnVuY3Rpb24oYykge1xuICAgIC8vIGluY29ycG9yYXRlIGNlbnRyb2lkIG9yIGFycmF5IG9mIGNlbnRyb2lkcyBjXG4gICAgLy9cbiAgICBjID0gQXJyYXkuaXNBcnJheShjKSA/IGMgOiBbY107XG4gICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgYy5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgdGhpcy5fZGlnZXN0KGNbaV0ubWVhbiwgY1tpXS5uKTtcbiAgICB9XG59O1xuXG5URGlnZXN0LnByb3RvdHlwZS5fY3VtdWxhdGUgPSBmdW5jdGlvbihleGFjdCkge1xuICAgIC8vIHVwZGF0ZSBjdW11bGF0aXZlIGNvdW50cyBmb3IgZWFjaCBjZW50cm9pZFxuICAgIC8vXG4gICAgLy8gZXhhY3Q6IGZhbHNleSBtZWFucyBvbmx5IGN1bXVsYXRlIGFmdGVyIHN1ZmZpY2llbnRcbiAgICAvLyBncm93dGguIER1cmluZyBpbmdlc3QsIHRoZXNlIGNvdW50cyBhcmUgdXNlZCBhcyBxdWFudGlsZVxuICAgIC8vIGVzdGltYXRlcywgYW5kIHRoZXkgd29yayB3ZWxsIGV2ZW4gd2hlbiBzb21ld2hhdCBvdXQgb2ZcbiAgICAvLyBkYXRlLiAodGhpcyBpcyBhIGRlcGFydHVyZSBmcm9tIHRoZSBwdWJsaWNhdGlvbiwgeW91IG1heSBzZXQgQ1hcbiAgICAvLyB0byAwIHRvIGRpc2FibGUpLlxuICAgIC8vXG4gICAgaWYgKHRoaXMubiA9PT0gdGhpcy5sYXN0X2N1bXVsYXRlIHx8XG4gICAgICAgICFleGFjdCAmJiB0aGlzLkNYICYmIHRoaXMuQ1ggPiAodGhpcy5uIC8gdGhpcy5sYXN0X2N1bXVsYXRlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjdW1uID0gMDtcbiAgICB0aGlzLmNlbnRyb2lkcy5lYWNoKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgYy5tZWFuX2N1bW4gPSBjdW1uICsgYy5uIC8gMjsgLy8gaGFsZiBvZiBuIGF0IHRoZSBtZWFuXG4gICAgICAgIGN1bW4gPSBjLmN1bW4gPSBjdW1uICsgYy5uO1xuICAgIH0pO1xuICAgIHRoaXMubiA9IHRoaXMubGFzdF9jdW11bGF0ZSA9IGN1bW47XG59O1xuXG5URGlnZXN0LnByb3RvdHlwZS5maW5kX25lYXJlc3QgPSBmdW5jdGlvbih4KSB7XG4gICAgLy8gZmluZCB0aGUgY2VudHJvaWQgY2xvc2VzdCB0byB4LiBUaGUgYXNzdW1wdGlvbiBvZlxuICAgIC8vIHVuaXF1ZSBtZWFucyBhbmQgYSB1bmlxdWUgbmVhcmVzdCBjZW50cm9pZCBkZXBhcnRzIGZyb20gdGhlXG4gICAgLy8gcGFwZXIsIHNlZSBfZGlnZXN0KCkgYmVsb3dcbiAgICAvL1xuICAgIGlmICh0aGlzLnNpemUoKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGl0ZXIgPSB0aGlzLmNlbnRyb2lkcy5sb3dlckJvdW5kKHttZWFuOnh9KTsgLy8geCA8PSBpdGVyIHx8IGl0ZXI9PW51bGxcbiAgICB2YXIgYyA9IChpdGVyLmRhdGEoKSA9PT0gbnVsbCkgPyBpdGVyLnByZXYoKSA6IGl0ZXIuZGF0YSgpO1xuICAgIGlmIChjLm1lYW4gPT09IHggfHwgdGhpcy5kaXNjcmV0ZSkge1xuICAgICAgICByZXR1cm4gYzsgLy8gYyBpcyBlaXRoZXIgeCBvciBhIG5laWdoYm9yIChkaXNjcmV0ZTogbm8gZGlzdGFuY2UgZnVuYylcbiAgICB9XG4gICAgdmFyIHByZXYgPSBpdGVyLnByZXYoKTtcbiAgICBpZiAocHJldiAmJiBNYXRoLmFicyhwcmV2Lm1lYW4gLSB4KSA8IE1hdGguYWJzKGMubWVhbiAtIHgpKSB7XG4gICAgICAgIHJldHVybiBwcmV2O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cbn07XG5cblREaWdlc3QucHJvdG90eXBlLl9uZXdfY2VudHJvaWQgPSBmdW5jdGlvbih4LCBuLCBjdW1uKSB7XG4gICAgLy8gY3JlYXRlIGFuZCBpbnNlcnQgYSBuZXcgY2VudHJvaWQgaW50byB0aGUgZGlnZXN0IChkb24ndCB1cGRhdGVcbiAgICAvLyBjdW11bGF0aXZlcykuXG4gICAgLy9cbiAgICB2YXIgYyA9IHttZWFuOngsIG46biwgY3VtbjpjdW1ufTtcbiAgICB0aGlzLmNlbnRyb2lkcy5pbnNlcnQoYyk7XG4gICAgdGhpcy5uICs9IG47XG4gICAgcmV0dXJuIGM7XG59O1xuXG5URGlnZXN0LnByb3RvdHlwZS5fYWRkd2VpZ2h0ID0gZnVuY3Rpb24obmVhcmVzdCwgeCwgbikge1xuICAgIC8vIGFkZCB3ZWlnaHQgYXQgbG9jYXRpb24geCB0byBuZWFyZXN0IGNlbnRyb2lkLiAgYWRkaW5nIHggdG9cbiAgICAvLyBuZWFyZXN0IHdpbGwgbm90IHNoaWZ0IGl0cyByZWxhdGl2ZSBwb3NpdGlvbiBpbiB0aGUgdHJlZSBhbmRcbiAgICAvLyByZXF1aXJlIHJlaW5zZXJ0aW9uLlxuICAgIC8vXG4gICAgaWYgKHggIT09IG5lYXJlc3QubWVhbikge1xuICAgICAgICBuZWFyZXN0Lm1lYW4gKz0gbiAqICh4IC0gbmVhcmVzdC5tZWFuKSAvIChuZWFyZXN0Lm4gKyBuKTtcbiAgICB9XG4gICAgbmVhcmVzdC5jdW1uICs9IG47XG4gICAgbmVhcmVzdC5tZWFuX2N1bW4gKz0gbiAvIDI7XG4gICAgbmVhcmVzdC5uICs9IG47XG4gICAgdGhpcy5uICs9IG47XG59O1xuXG5URGlnZXN0LnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24oeCwgbikge1xuICAgIC8vIGluY29ycG9yYXRlIHZhbHVlIHgsIGhhdmluZyBjb3VudCBuIGludG8gdGhlIFREaWdlc3QuXG4gICAgLy9cbiAgICB2YXIgbWluID0gdGhpcy5jZW50cm9pZHMubWluKCk7XG4gICAgdmFyIG1heCA9IHRoaXMuY2VudHJvaWRzLm1heCgpO1xuICAgIHZhciBuZWFyZXN0ID0gdGhpcy5maW5kX25lYXJlc3QoeCk7XG4gICAgaWYgKG5lYXJlc3QgJiYgbmVhcmVzdC5tZWFuID09PSB4KSB7XG4gICAgICAgIC8vIGFjY3VtdWxhdGUgZXhhY3QgbWF0Y2hlcyBpbnRvIHRoZSBjZW50cm9pZCB3aXRob3V0XG4gICAgICAgIC8vIGxpbWl0LiB0aGlzIGlzIGEgZGVwYXJ0dXJlIGZyb20gdGhlIHBhcGVyLCBtYWRlIHNvXG4gICAgICAgIC8vIGNlbnRyb2lkcyByZW1haW4gdW5pcXVlIGFuZCBjb2RlIGNhbiBiZSBzaW1wbGUuXG4gICAgICAgIHRoaXMuX2FkZHdlaWdodChuZWFyZXN0LCB4LCBuKTtcbiAgICB9IGVsc2UgaWYgKG5lYXJlc3QgPT09IG1pbikge1xuICAgICAgICB0aGlzLl9uZXdfY2VudHJvaWQoeCwgbiwgMCk7IC8vIG5ldyBwb2ludCBhcm91bmQgbWluIGJvdW5kYXJ5XG4gICAgfSBlbHNlIGlmIChuZWFyZXN0ID09PSBtYXggKSB7XG4gICAgICAgIHRoaXMuX25ld19jZW50cm9pZCh4LCBuLCB0aGlzLm4pOyAvLyBuZXcgcG9pbnQgYXJvdW5kIG1heCBib3VuZGFyeVxuICAgIH0gZWxzZSBpZiAodGhpcy5kaXNjcmV0ZSkge1xuICAgICAgICB0aGlzLl9uZXdfY2VudHJvaWQoeCwgbiwgbmVhcmVzdC5jdW1uKTsgLy8gbmV2ZXIgbWVyZ2VcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjb25pZGVyIGEgbWVyZ2UgYmFzZWQgb24gbmVhcmVzdCBjZW50cm9pZCdzIGNhcGFjaXR5LiBpZlxuICAgICAgICAvLyB0aGVyZSdzIG5vdCByb29tIGZvciBhbGwgb2YgbiwgZG9uJ3QgYm90aGVyIG1lcmdpbmcgYW55IG9mXG4gICAgICAgIC8vIGl0IGludG8gbmVhcmVzdCwgYXMgd2UnbGwgaGF2ZSB0byBtYWtlIGEgbmV3IGNlbnRyb2lkXG4gICAgICAgIC8vIGFueXdheSBmb3IgdGhlIHJlbWFpbmRlciAoZGVwYXJ0dXJlIGZyb20gdGhlIHBhcGVyKS5cbiAgICAgICAgdmFyIHAgPSBuZWFyZXN0Lm1lYW5fY3VtbiAvIHRoaXMubjtcbiAgICAgICAgdmFyIG1heF9uID0gTWF0aC5mbG9vcig0ICogdGhpcy5uICogdGhpcy5kZWx0YSAqIHAgKiAoMSAtIHApKTtcbiAgICAgICAgaWYgKG1heF9uIC0gbmVhcmVzdC5uID49IG4pIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZHdlaWdodChuZWFyZXN0LCB4LCBuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX25ld19jZW50cm9pZCh4LCBuLCBuZWFyZXN0LmN1bW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2N1bXVsYXRlKGZhbHNlKTtcbiAgICBpZiAoIXRoaXMuZGlzY3JldGUgJiYgdGhpcy5LICYmIHRoaXMuc2l6ZSgpID4gdGhpcy5LIC8gdGhpcy5kZWx0YSkge1xuICAgICAgICAvLyByZS1wcm9jZXNzIHRoZSBjZW50cm9pZHMgYW5kIGhvcGUgZm9yIHNvbWUgY29tcHJlc3Npb24uXG4gICAgICAgIHRoaXMuY29tcHJlc3MoKTtcbiAgICB9XG59O1xuXG5URGlnZXN0LnByb3RvdHlwZS5ib3VuZF9tZWFuID0gZnVuY3Rpb24oeCkge1xuICAgIC8vIGZpbmQgY2VudHJvaWRzIGxvd2VyIGFuZCB1cHBlciBzdWNoIHRoYXQgbG93ZXIubWVhbiA8IHggPFxuICAgIC8vIHVwcGVyLm1lYW4gb3IgbG93ZXIubWVhbiA9PT0geCA9PT0gdXBwZXIubWVhbi4gRG9uJ3QgY2FsbFxuICAgIC8vIHRoaXMgZm9yIHggb3V0IG9mIGJvdW5kcy5cbiAgICAvL1xuICAgIHZhciBpdGVyID0gdGhpcy5jZW50cm9pZHMudXBwZXJCb3VuZCh7bWVhbjp4fSk7IC8vIHggPCBpdGVyXG4gICAgdmFyIGxvd2VyID0gaXRlci5wcmV2KCk7ICAgICAgLy8gbG93ZXIgPD0geFxuICAgIHZhciB1cHBlciA9IChsb3dlci5tZWFuID09PSB4KSA/IGxvd2VyIDogaXRlci5uZXh0KCk7XG4gICAgcmV0dXJuIFtsb3dlciwgdXBwZXJdO1xufTtcblxuVERpZ2VzdC5wcm90b3R5cGUucF9yYW5rID0gZnVuY3Rpb24oeF9vcl94bGlzdCkge1xuICAgIC8vIHJldHVybiBhcHByb3hpbWF0ZSBwZXJjZW50aWxlLXJhbmtzICgwLi4xKSBmb3IgZGF0YSB2YWx1ZSB4LlxuICAgIC8vIG9yIGxpc3Qgb2YgeC4gIGNhbGN1bGF0ZWQgYWNjb3JkaW5nIHRvXG4gICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUGVyY2VudGlsZV9yYW5rXG4gICAgLy9cbiAgICAvLyAoTm90ZSB0aGF0IGluIGNvbnRpbnVvdXMgbW9kZSwgYm91bmRhcnkgc2FtcGxlIHZhbHVlcyB3aWxsXG4gICAgLy8gcmVwb3J0IGhhbGYgdGhlaXIgY2VudHJvaWQgd2VpZ2h0IGlud2FyZCBmcm9tIDAvMSBhcyB0aGVcbiAgICAvLyBwZXJjZW50aWxlLXJhbmsuIFggdmFsdWVzIG91dHNpZGUgdGhlIG9ic2VydmVkIHJhbmdlIHJldHVyblxuICAgIC8vIDAvMSlcbiAgICAvL1xuICAgIC8vIHRoaXMgdHJpZ2dlcnMgY3VtdWxhdGUoKSBpZiBjdW1uJ3MgYXJlIG91dCBvZiBkYXRlLlxuICAgIC8vXG4gICAgdmFyIHhzID0gQXJyYXkuaXNBcnJheSh4X29yX3hsaXN0KSA/IHhfb3JfeGxpc3QgOiBbeF9vcl94bGlzdF07XG4gICAgdmFyIHBzID0geHMubWFwKHRoaXMuX3BfcmFuaywgdGhpcyk7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoeF9vcl94bGlzdCkgPyBwcyA6IHBzWzBdO1xufTtcblxuVERpZ2VzdC5wcm90b3R5cGUuX3BfcmFuayA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAodGhpcy5zaXplKCkgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHggPCB0aGlzLmNlbnRyb2lkcy5taW4oKS5tZWFuKSB7XG4gICAgICAgIHJldHVybiAwLjA7XG4gICAgfSBlbHNlIGlmICh4ID4gdGhpcy5jZW50cm9pZHMubWF4KCkubWVhbikge1xuICAgICAgICByZXR1cm4gMS4wO1xuICAgIH1cbiAgICAvLyBmaW5kIGNlbnRyb2lkcyB0aGF0IGJyYWNrZXQgeCBhbmQgaW50ZXJwb2xhdGUgeCdzIGN1bW4gZnJvbVxuICAgIC8vIHRoZWlyIGN1bW4ncy5cbiAgICB0aGlzLl9jdW11bGF0ZSh0cnVlKTsgLy8gYmUgc3VyZSBjdW1ucyBhcmUgZXhhY3RcbiAgICB2YXIgYm91bmQgPSB0aGlzLmJvdW5kX21lYW4oeCk7XG4gICAgdmFyIGxvd2VyID0gYm91bmRbMF0sIHVwcGVyID0gYm91bmRbMV07XG4gICAgaWYgKHRoaXMuZGlzY3JldGUpIHtcbiAgICAgICAgcmV0dXJuIGxvd2VyLmN1bW4gLyB0aGlzLm47XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGN1bW4gPSBsb3dlci5tZWFuX2N1bW47XG4gICAgICAgIGlmIChsb3dlciAhPT0gdXBwZXIpIHtcbiAgICAgICAgICAgIGN1bW4gKz0gKHggLSBsb3dlci5tZWFuKSAqICh1cHBlci5tZWFuX2N1bW4gLSBsb3dlci5tZWFuX2N1bW4pIC8gKHVwcGVyLm1lYW4gLSBsb3dlci5tZWFuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VtbiAvIHRoaXMubjtcbiAgICB9XG59O1xuXG5URGlnZXN0LnByb3RvdHlwZS5ib3VuZF9tZWFuX2N1bW4gPSBmdW5jdGlvbihjdW1uKSB7XG4gICAgLy8gZmluZCBjZW50cm9pZHMgbG93ZXIgYW5kIHVwcGVyIHN1Y2ggdGhhdCBsb3dlci5tZWFuX2N1bW4gPCB4IDxcbiAgICAvLyB1cHBlci5tZWFuX2N1bW4gb3IgbG93ZXIubWVhbl9jdW1uID09PSB4ID09PSB1cHBlci5tZWFuX2N1bW4uIERvbid0IGNhbGxcbiAgICAvLyB0aGlzIGZvciBjdW1uIG91dCBvZiBib3VuZHMuXG4gICAgLy9cbiAgICAvLyBYWFggYmVjYXVzZSBtZWFuIGFuZCBtZWFuX2N1bW4gZ2l2ZSByaXNlIHRvIHRoZSBzYW1lIHNvcnQgb3JkZXJcbiAgICAvLyAodXAgdG8gaWRlbnRpY2FsIG1lYW5zKSwgdXNlIHRoZSBtZWFuIHJidHJlZSBmb3Igb3VyIHNlYXJjaC5cbiAgICB0aGlzLmNlbnRyb2lkcy5fY29tcGFyYXRvciA9IGNvbXBhcmVfY2VudHJvaWRfbWVhbl9jdW1ucztcbiAgICB2YXIgaXRlciA9IHRoaXMuY2VudHJvaWRzLnVwcGVyQm91bmQoe21lYW5fY3VtbjpjdW1ufSk7IC8vIGN1bW4gPCBpdGVyXG4gICAgdGhpcy5jZW50cm9pZHMuX2NvbXBhcmF0b3IgPSBjb21wYXJlX2NlbnRyb2lkX21lYW5zO1xuICAgIHZhciBsb3dlciA9IGl0ZXIucHJldigpOyAgICAgIC8vIGxvd2VyIDw9IGN1bW5cbiAgICB2YXIgdXBwZXIgPSAobG93ZXIgJiYgbG93ZXIubWVhbl9jdW1uID09PSBjdW1uKSA/IGxvd2VyIDogaXRlci5uZXh0KCk7XG4gICAgcmV0dXJuIFtsb3dlciwgdXBwZXJdO1xufTtcblxuVERpZ2VzdC5wcm90b3R5cGUucGVyY2VudGlsZSA9IGZ1bmN0aW9uKHBfb3JfcGxpc3QpIHtcbiAgICAvLyBmb3IgcGVyY2VudGFnZSBwICgwLi4xKSwgb3IgZm9yIGVhY2ggcCBpbiBhIGxpc3Qgb2YgcHMsIHJldHVyblxuICAgIC8vIHRoZSBzbWFsbGVzdCBkYXRhIHZhbHVlIHEgYXQgd2hpY2ggYXQgbGVhc3QgcCBwZXJjZW50IG9mIHRoZVxuICAgIC8vIG9ic2VydmF0aW9ucyA8PSBxLlxuICAgIC8vXG4gICAgLy8gZm9yIGRpc2NyZXRlIGRpc3RyaWJ1dGlvbnMsIHRoaXMgc2VsZWN0cyBxIHVzaW5nIHRoZSBOZWFyZXN0XG4gICAgLy8gUmFuayBNZXRob2RcbiAgICAvLyAoaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUGVyY2VudGlsZSNUaGVfTmVhcmVzdF9SYW5rX21ldGhvZClcbiAgICAvLyAoaW4gc2NpcHksIHNhbWUgYXMgcGVyY2VudGlsZSguLi4uLCBpbnRlcnBvbGF0aW9uPSdoaWdoZXInKVxuICAgIC8vXG4gICAgLy8gZm9yIGNvbnRpbnVvdXMgZGlzdHJpYnV0aW9ucywgaW50ZXJwb2xhdGVzIGRhdGEgdmFsdWVzIGJldHdlZW5cbiAgICAvLyBjb3VudC13ZWlnaHRlZCBicmFja2V0aW5nIG1lYW5zLlxuICAgIC8vXG4gICAgLy8gdGhpcyB0cmlnZ2VycyBjdW11bGF0ZSgpIGlmIGN1bW4ncyBhcmUgb3V0IG9mIGRhdGUuXG4gICAgLy9cbiAgICB2YXIgcHMgPSBBcnJheS5pc0FycmF5KHBfb3JfcGxpc3QpID8gcF9vcl9wbGlzdCA6IFtwX29yX3BsaXN0XTtcbiAgICB2YXIgcXMgPSBwcy5tYXAodGhpcy5fcGVyY2VudGlsZSwgdGhpcyk7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocF9vcl9wbGlzdCkgPyBxcyA6IHFzWzBdO1xufTtcblxuVERpZ2VzdC5wcm90b3R5cGUuX3BlcmNlbnRpbGUgPSBmdW5jdGlvbihwKSB7XG4gICAgaWYgKHRoaXMuc2l6ZSgpID09PSAwKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRoaXMuX2N1bXVsYXRlKHRydWUpOyAvLyBiZSBzdXJlIGN1bW5zIGFyZSBleGFjdFxuICAgIHZhciBoID0gdGhpcy5uICogcDtcbiAgICB2YXIgYm91bmQgPSB0aGlzLmJvdW5kX21lYW5fY3VtbihoKTtcbiAgICB2YXIgbG93ZXIgPSBib3VuZFswXSwgdXBwZXIgPSBib3VuZFsxXTtcblxuICAgIGlmICh1cHBlciA9PT0gbG93ZXIgfHwgbG93ZXIgPT09IG51bGwgfHwgdXBwZXIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIChsb3dlciB8fCB1cHBlcikubWVhbjtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmRpc2NyZXRlKSB7XG4gICAgICAgIHJldHVybiBsb3dlci5tZWFuICsgKGggLSBsb3dlci5tZWFuX2N1bW4pICogKHVwcGVyLm1lYW4gLSBsb3dlci5tZWFuKSAvICh1cHBlci5tZWFuX2N1bW4gLSBsb3dlci5tZWFuX2N1bW4pO1xuICAgIH0gZWxzZSBpZiAoaCA8PSBsb3dlci5jdW1uKSB7XG4gICAgICAgIHJldHVybiBsb3dlci5tZWFuO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1cHBlci5tZWFuO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIHBvcF9yYW5kb20oY2hvaWNlcykge1xuICAgIC8vIHJlbW92ZSBhbmQgcmV0dXJuIGFuIGl0ZW0gcmFuZG9tbHkgY2hvc2VuIGZyb20gdGhlIGFycmF5IG9mIGNob2ljZXNcbiAgICAvLyAobXV0YXRlcyBjaG9pY2VzKVxuICAgIC8vXG4gICAgdmFyIGlkeCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNob2ljZXMubGVuZ3RoKTtcbiAgICByZXR1cm4gY2hvaWNlcy5zcGxpY2UoaWR4LCAxKVswXTtcbn1cblxuVERpZ2VzdC5wcm90b3R5cGUuY29tcHJlc3MgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBURGlnZXN0cyBleHBlcmllbmNlIHdvcnN0IGNhc2UgY29tcHJlc3Npb24gKG5vbmUpIHdoZW4gaW5wdXRcbiAgICAvLyBpbmNyZWFzZXMgbW9ub3RvbmljYWxseS4gIEltcHJvdmUgb24gYW55IGJhZCBsdWNrIGJ5XG4gICAgLy8gcmVjb25zdW1pbmcgZGlnZXN0IGNlbnRyb2lkcyBhcyBpZiB0aGV5IHdlcmUgd2VpZ2h0ZWQgcG9pbnRzXG4gICAgLy8gd2hpbGUgc2h1ZmZsaW5nIHRoZWlyIG9yZGVyIChhbmQgaG9wZSBmb3IgdGhlIGJlc3QpLlxuICAgIC8vXG4gICAgaWYgKHRoaXMuY29tcHJlc3NpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcG9pbnRzID0gdGhpcy50b0FycmF5KCk7XG4gICAgdGhpcy5yZXNldCgpO1xuICAgIHRoaXMuY29tcHJlc3NpbmcgPSB0cnVlO1xuICAgIHdoaWxlIChwb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnB1c2hfY2VudHJvaWQocG9wX3JhbmRvbShwb2ludHMpKTtcbiAgICB9XG4gICAgdGhpcy5fY3VtdWxhdGUodHJ1ZSk7XG4gICAgdGhpcy5jb21wcmVzc2luZyA9IGZhbHNlO1xufTtcblxuZnVuY3Rpb24gRGlnZXN0KGNvbmZpZykge1xuICAgIC8vIGFsbG9jYXRlIGEgZGlzdHJpYnV0aW9uIGRpZ2VzdCBzdHJ1Y3R1cmUuIFRoaXMgaXMgYW4gZXh0ZW5zaW9uXG4gICAgLy8gb2YgYSBURGlnZXN0IHN0cnVjdHVyZSB0aGF0IHN0YXJ0cyBpbiBleGFjdCBoaXN0b2dyYW0gKGRpc2NyZXRlKVxuICAgIC8vIG1vZGUsIGFuZCBhdXRvbWF0aWNhbGx5IHN3aXRjaGVzIHRvIFREaWdlc3QgbW9kZSBmb3IgbGFyZ2VcbiAgICAvLyBzYW1wbGVzIHRoYXQgYXBwZWFyIHRvIGJlIGZyb20gYSBjb250aW51b3VzIGRpc3RyaWJ1dGlvbi5cbiAgICAvL1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgIHRoaXMubW9kZSA9IHRoaXMuY29uZmlnLm1vZGUgfHwgJ2F1dG8nOyAvLyBkaXNjLCBjb250LCBhdXRvXG4gICAgVERpZ2VzdC5jYWxsKHRoaXMsIHRoaXMubW9kZSA9PT0gJ2NvbnQnID8gY29uZmlnLmRlbHRhIDogZmFsc2UpO1xuICAgIHRoaXMuZGlnZXN0X3JhdGlvID0gdGhpcy5jb25maWcucmF0aW8gfHwgMC45O1xuICAgIHRoaXMuZGlnZXN0X3RocmVzaCA9IHRoaXMuY29uZmlnLnRocmVzaCB8fCAxMDAwO1xuICAgIHRoaXMubl91bmlxdWUgPSAwO1xufVxuRGlnZXN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVERpZ2VzdC5wcm90b3R5cGUpO1xuRGlnZXN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERpZ2VzdDtcblxuRGlnZXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oeF9vcl94bGlzdCkge1xuICAgIFREaWdlc3QucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCB4X29yX3hsaXN0KTtcbiAgICB0aGlzLmNoZWNrX2NvbnRpbnVvdXMoKTtcbn07XG5cbkRpZ2VzdC5wcm90b3R5cGUuX25ld19jZW50cm9pZCA9IGZ1bmN0aW9uKHgsIG4sIGN1bW4pIHtcbiAgICB0aGlzLm5fdW5pcXVlICs9IDE7XG4gICAgVERpZ2VzdC5wcm90b3R5cGUuX25ld19jZW50cm9pZC5jYWxsKHRoaXMsIHgsIG4sIGN1bW4pO1xufTtcblxuRGlnZXN0LnByb3RvdHlwZS5fYWRkd2VpZ2h0ID0gZnVuY3Rpb24obmVhcmVzdCwgeCwgbikge1xuICAgIGlmIChuZWFyZXN0Lm4gPT09IDEpIHtcbiAgICAgICAgdGhpcy5uX3VuaXF1ZSAtPSAxO1xuICAgIH1cbiAgICBURGlnZXN0LnByb3RvdHlwZS5fYWRkd2VpZ2h0LmNhbGwodGhpcywgbmVhcmVzdCwgeCwgbik7XG59O1xuXG5EaWdlc3QucHJvdG90eXBlLmNoZWNrX2NvbnRpbnVvdXMgPSBmdW5jdGlvbigpIHtcbiAgICAvLyB3aGlsZSBpbiAnYXV0bycgbW9kZSwgaWYgdGhlcmUgYXJlIG1hbnkgdW5pcXVlIGVsZW1lbnRzLCBhc3N1bWVcbiAgICAvLyB0aGV5IGFyZSBmcm9tIGEgY29udGludW91cyBkaXN0cmlidXRpb24gYW5kIHN3aXRjaCB0byAnY29udCdcbiAgICAvLyBtb2RlICh0ZGlnZXN0IGJlaGF2aW9yKS4gUmV0dXJuIHRydWUgb24gdHJhbnNpdGlvbiBmcm9tXG4gICAgLy8gZGlzY3RldGUgdG8gY29udGludW91cy5cbiAgICBpZiAodGhpcy5tb2RlICE9PSAnYXV0bycgfHwgdGhpcy5zaXplKCkgPCB0aGlzLmRpZ2VzdF90aHJlc2gpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5uX3VuaXF1ZSAvIHRoaXMuc2l6ZSgpID4gdGhpcy5kaWdlc3RfcmF0aW8pIHtcbiAgICAgICAgdGhpcy5tb2RlID0gJ2NvbnQnO1xuICAgICAgICB0aGlzLmRpc2NyZXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVsdGEgPSB0aGlzLmNvbmZpZy5kZWx0YSB8fCAwLjAxO1xuICAgICAgICB0aGlzLmNvbXByZXNzKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAnVERpZ2VzdCc6IFREaWdlc3QsXG4gICAgJ0RpZ2VzdCc6IERpZ2VzdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/tdigest/tdigest.js\n");

/***/ })

};
;